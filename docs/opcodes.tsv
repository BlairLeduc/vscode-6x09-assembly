Name	Processor	Condition Codes	Summary	Notation	Documentation
ABX	6809	H=• N=• Z=• V=• C=•	Add B into X (Unsigned)	X' ← X + B	Add the unsigned value in B into X.
ADCA	6809	H=↕ N=↕ Z=↕ V=↕ C=↕	Add Memory Byte with Carry into A	A' ← A + M + C	Add A, the C (carry) bit and the memory byte into A.
ADCB	6809	H=↕ N=↕ Z=↕ V=↕ C=↕	Add Memory Byte with Carry into B	B' ← B + M + C	Add B, the C (carry) bit and the memory byte into B.
ADCD	6309	H=• N=↕ Z=↕ V=↕ C=↕	Add Memory Word with Carry into D	D' ← D + M:M+1 + C	Add D, the C (carry) bit and the memory word into D.
ADCR	6309	H=• N=↕ Z=↕ V=↕ C=↕	Add Register with Carry into Register	R₁' ← R₁ + R₀ + C	Add R₁, the C (carry) bit and R₀ into R₁.
ADDA	6809	H=↕ N=↕ Z=↕ V=↕ C=↕	Add Memory Byte into A	A' ← A + M	Add A and the memory byte into A.
ADDB	6809	H=↕ N=↕ Z=↕ V=↕ C=↕	Add Memory Byte into B	B' ← B + M	Add B and the memory byte into B.
ADDD	6809	H=• N=↕ Z=↕ V=↕ C=↕	Add Memory Word into D	D' ← D + M:M+1	Add D and the memory word into D.
ADDE	6309	H=↕ N=↕ Z=↕ V=↕ C=↕	Add Memory Byte into E	E' ← E + M	Add E and the memory byte into E.
ADDF	6309	H=↕ N=↕ Z=↕ V=↕ C=↕	Add Memory Byte into F	F' ← F + M	Add F and the memory byte into F.
ADDR	6309	H=• N=↕ Z=↕ V=↕ C=↕	Add Register into Register	R₁' ← R₁ + R₀	Add R₁ and R₀ into R₁.
ADDW	6309	H=• N=↕ Z=↕ V=↕ C=↕	Add Memory Word into W	W' ← W + M:M+1	Add W and the memory word into W.
AIM	6309	H=• N=↕ Z=↕ V=0 C=•	Logical AND of Immediate Byte with Memory Byte	M' ← M ∩ I	Logical AND the memory byte and the immediate byte and store in the memory byte.
ANDA	6809	H=• N=↕ Z=↕ V=0 C=•	Logical AND Memory Byte into A	A' ← A ∩ M	Logical AND A and the memory byte into A.
ANDB	6809	H=• N=↕ Z=↕ V=0 C=•	Logical AND Memory Byte into B	B' ← B ∩ M	Logical AND B and the memory byte into B.
ANDD	6309	H=• N=↕ Z=↕ V=0 C=•	Logical AND Memory Word into D	D' ← D ∩ M:M+1	Logical AND D and memory word into D.
ANDR	6309	H=• N=↕ Z=↕ V=0 C=•	Logical AND Register into Register	R₁' ← R₁ ∩ R₀	Logical AND R₁ and R₀ into R₁.
ANDCC	6809	H=↕ N=↕ Z=↕ V=↕ C=↕	Logical AND Immediate Byte into CC	CC' ← CC ∩ I	Logical AND the condition code register and the immediate byte into the condition code register.
ASL	6809	H=? N=↕ Z=↕ V=↕ C=↕	Arithmetic Shift Left of Memory Byte, Equivalant of LSL	C ←□□□□□□□□← 0	Shift all bits of the memory byte to the left and store in the memory byte. Bit zero is loaded with a zero. Bit seven is shifted into the C (carry) bit.!!- The value of the H (half-carry) bit is undefined.!- Equivalent to LSL.
ASLA	6809	H=? N=↕ Z=↕ V=↕ C=↕	Arithmetic Shift Left of A, Equivalant of LSLA	C ←□□□□□□□□← 0	Shift all bits of A one place to the left and store in A. Bit zero is loaded with a zero. Bit seven is shifted into the C (carry) bit.!!- The value of the H (half-carry) bit is undefined.!- Equivalent to LSLA.
ASLB	6809	H=? N=↕ Z=↕ V=↕ C=↕	Arithmetic Shift Left of B, Equivalant of LSLB	C ←□□□□□□□□← 0	Shift all bits of B one place to the left and store in B. Bit zero is loaded with a zero. Bit seven is shifted into the C (carry) bit.!!- The value of the H (half-carry) bit is undefined.!- Equivalent to LSLB.
ASLD	6309	H=• N=↕ Z=↕ V=↕ C=↕	Arithmetic Shift Left of D, Equivalant of LSLD	C ←□□□□□□□□□□□□□□□□← 0	Shift all bits of D one place to the left and store in D. Bit zero is loaded with a zero. Bit fifteen is shifted into the C (carry) bit.!!Equivalent to LSLD.
ASR	6809	H=? N=↕ Z=↕ V=• C=↕	Arithmetic Shift Right of Memory Byte	b7 →□□□□□□□□→ C	Shift all bits of the memory byte one place to the right and store in the memory byte. Bit seven is held constant. Bit zero is shifted into the C (carry) bit.!!The resultant value of the H (half-carry) bit is undefined.
ASRA	6809	H=? N=↕ Z=↕ V=• C=↕	Arithmetic Shift Right of A	b7 →□□□□□□□□→ C	Shift all bits of A one place to the right and store in A. Bit seven is held constant. Bit zero is shifted into the C (carry) bit.!!The resultant value of the H (half-carry) bit is undefined.
ASRB	6809	H=? N=↕ Z=↕ V=• C=↕	Arithmetic Shift Right of B	b7 →□□□□□□□□→ C	Shift all bits of B one place to the right and store in B. Bit seven is held constant. Bit zero is shifted into the C (carry) bit.!!The resultant value of the H (half-carry) bit is undefined.
ASRD	6309	H=• N=↕ Z=↕ V=• C=↕	Arithmetic Shift Right of D	b7 →□□□□□□□□□□□□□□□□→ C	Shift all bits of D one place to the right and store in D. Bit fifteen is held constant. Bit zero is shifted into the C (carry) bit.
BCC	6809	H=• N=• Z=• V=• C=•	Branch if Carry Clear (C=0), Equivalent to BHS (Unsigned)	IF C=0 then PC' ← PC + I	Test the state of the C (carry) bit and causes a branch if it is is clear.!!*Equivalent to BHS.*
BCS	6809	H=• N=• Z=• V=• C=•	Branch if Carry Set (C=1), Equivalent to BLO (Unsigned)	If C=1 then PC' ← PC + I	Test the state of the C (carry) bit and causes a branch if it is is set.!!*Equivalent to BLO.*
BEQ	6809	H=• N=• Z=• V=• C=•	Branch if Equal (Z=1)	If Z=1 then PC' ← PC + I	Test the state of the Z (zero) bit and causes a branch if it is set. When used after a subtract or compare operation, this instruction will branch if the compared values, signed or unsigned, were exactly the same.
BGE	6809	H=• N=• Z=• V=• C=•	Branch if Greater Than or Equal to Zero (Z=1 or N EOR V=0) (Signed)	If [N ⊕ V]=0 then PC' ← PC + I	Causes a branch if the N (negative) bit and the V (overflow) bit are either both set or both clear. That is, branch if the sign of a valid two's complement result is, or would be, positive. When used after a subtract or compare operation on two's complement values, this instruction will branch if the register was greater than or equal to the memory operand.
BGT	6809	H=• N=• Z=• V=• C=•	Branch if Greater (N EOR V=0) (Signed)	If Z ∩ [N ⊕ V]=0 then PC' ← PC + I	Causes a branch if the N (negative) bit and V (overflow) bit are either both set or both clear and the Z (zero) bit is clear. In other words, branch if the sign of a valid two's complement result is, or would be, positive and not zero. When used after a subtract or compare operation on two's complement values, this instruction will branch if the register was greater than the memory operand.
BHI	6809	H=• N=• Z=• V=• C=•	Branch if Higher (Z=0 and C=0) (Unsigned)	If [C ∪ Z]=0 then PC' ← PC + I	Causes a branch if the previous operation caused neither a carry nor a zero result. When used after a subtract or compare operation on unsigned binary values, this instruction will branch if the register was higher than the memory operand.!!Generally not useful after INC/DEC, LD/TST, and TST/CLR/COM instructions.
BHS	6809	H=• N=• Z=• V=• C=•	Branch if Higher or Same (C=0), Equivalent to BCC (Unsigned)	If C=0 then PC' ← PC + I	Test the state of the C (carry) bit and causes a branch if it is clear. When used after a subtract or compare on unsigned binary values, this instruction will branch if the register was higher than or the same as the memory operand.!!This is a duplicate assembly-language mnemonic for the single machine instruction BCC. Generally not useful after INC/DEC, LD/ST, and TST/CLR/COM instructions.!!*Equivalent to BCC.*
BLE	6809	H=• N=• Z=• V=• C=•	Branch if Less than or Equal to Zero (Z=1 or N EOR V=0) (Signed)	If Z ∪ [N ⊕ V]=0 then PC' ← PC + I	Causes a branch if the exclusive OR of the N (negative) and V (overflow) bits is 1 or if the Z (zero) bit is set. That is, branch if the sign of a valid two's complement result is, or would be, negative. When used after a subtract or compare operation on two's complement values, this instruction will branch if the register was less than or equal to the memory operand.
BLO	6809	H=• N=• Z=• V=• C=•	Branch if Lower (C=1), Equivalent to BCS (Unsigned)	If C=1 then PC' ← PC + I	Test the state of the (carry) bit and causes a branch if it is set. When used after a subtract or compare on unsigned binary values, this instruction will branch if the register was lower than the memory operand.!!This is a duplicate assembly-language mnemonic for the single machine instruction BCS. Generally not useful after INC/DEC.!!*Equivalent to BCS.*
BLS	6809	H=• N=• Z=• V=• C=•	Branch if Lower or Same (Z=1 or C=1) (Unsigned)	If [C ∪ Z]=1 then PC' ← PC + I	Causes a branch if the previous operation caused either a carry or a zero result. When used after a subtract or compare operation on unsigned binary values, this instruction will branch if the register was lower than or the same as the memory operand.!!Generally not useful after INC/DEC, LD/ST, and TST/CLR/COM instructions.
BLT	6809	H=• N=• Z=• V=• C=•	Branch if Less than Zero (N EOR V=1) (Signed)	If [N ⊕ V]=1 then PC' ← PC + I	Causes a branch if either, but not both, of the N (negative) or V (overflow) bits is set. That is, branch if the sign of a valid two's complement result is, or would be, negative. When used after a subtract or compare operation on two's complement binary values, this instruction will branch if the register was less than the memory operand.
BMI	6809	H=• N=• Z=• V=• C=•	Branch if Minus (N=1)	If N=1 then PC' ← PC + I	Test the state of the N (negative) bit and causes a branch if set. That is, branch if the sign of the two's compiement result is negative.!!When used after an operation on signed binary values, this instruction will branch if the result is minus. It is generally preferred to use the BLT instruction after signed operations.
BNE	6809	H=• N=• Z=• V=• C=•	Branch Not Equal (Z=0)	If Z=0 then PC' ← PC + I	Test the state of the Z (zero) bit and causes a branch if it is clear. When used after a subtract or compare operation on any binary values, this instruction will branch if the register is, or would be, not equal to the memory operand.
BPL	6809	H=• N=• Z=• V=• C=•	Branch if Plus (N=0)	If N=0 then PC' ← PC + I	Test the state of the N (negative) bit and causes a branch if it is clear. That is, branch if the sign of the two's complement result is positive.!!When used after an operation on signed binary values, this instruction will branch if the result (possibly invalid) is positive. It is generally preferred to use the BGE instruction after signed operations.
BRA	6809	H=• N=• Z=• V=• C=•	Branch Always	PC' ← PC + I	Causes an unconditlonal branch.
BRN	6809	H=• N=• Z=• V=• C=•	Branch Never (NOP)	NOP	Does not cause a branch. This instruction is essentially a no operation, but has a bit pattern logically related to branch always.
BSR	6809	H=• N=• Z=• V=• C=•	Branch to Subroutine	S' ← S - 2, [S]' ← PC, PC' ← PC + I	The program counter is pushed onto the stack. The program counter is then loaded with the sum of the program counter and the offset.!!A return from subroutine (RTS) instruction is used to reverse this process and must be the last instruction executed in a subroutine.
BVC	6809	H=• N=• Z=• V=• C=•	Branch if valid two's complement result (V=0)	If V=0 then PC' ← PC + I	Test the state of the V (overflow) bit and causes a branch if it is clear. That is, branch if the two's complement result was valid. When used after an operation on two's complement binary values, this instruction will branch if there was no overflow.
BVS	6809	H=• N=• Z=• V=• C=•	Branch if invalid two's complement result (V=1)	If V=1 then PC' ← PC + I	Test the state of the V (overflow) bit and causes a branch if it is set. That is, branch if the two's complement result was invalid. When used after an operation on two's complement binary values, this instruction will branch if there was an overflow.
BAND	6309	H=• N=• Z=• V=• C=•	Logical AND Register Bit with Memory Bit into Register Bit	R.d' ← R.d AND DPM.s	Logical AND bit s of the contents of direct addressed memory byte into bit d of the contents of R.
BEOR	6309	H=• N=• Z=• V=• C=•	Logical EOR Register Bit with Memory Bit into Register Bit	R.d' ← R.d EOR DPM.s	Exclusive OR bit s of the contents of direct addressed memory byte into bit d of the contents of R.
BIAND	6309	H=• N=• Z=• V=• C=•	Logical AND Register Bit with Inverted Memory Bit into Register Bit	R.d' ← R.d ∩ DPM.s̅	Logically AND inverted bit s of the contents of direct addressed memory byte into bit d of the contents of R.
BIEOR	6309	H=• N=• Z=• V=• C=•	Logical EOR Register Bit with Inverted Memory Bit into Register Bit	R.d' ← R.d ⊕ DPM.s̅	Exclusive OR inverted bit s of the contents of direct addressed memory byte into bit d of the contents of R.
BIOR	6309	H=• N=• Z=• V=• C=•	Logical OR Register Bit with Inverted Memory Bit into Register Bit	R.d' ← R.d ∪ DPM.s̅	Locially OR inverted bit s of the contents of direct addressed memory byte into bit d of the contents of R.
BITA	6809	H=• N=↕ Z=↕ V=0 C=•	Bit Test with A	TEMP ← R ∩ M	Logical AND of A and the memory byte and modifies the condition codes accordingly. The contents of A and the memory byte are not affected.
BITB	6809	H=• N=↕ Z=↕ V=0 C=•	Bit Test with B	TEMP ← R ∩ M	Logical AND of B and the memory byte and modifies the condition codes accordingly. The contents of B and the memory byte are not affected.
BITD	6309	H=• N=↕ Z=↕ V=0 C=•	Bit Test with D	TEMP ← R ∩ M	Logical AND of D and the memory word and modifies the condition codes accordingly. The contents of D and the memory word are not affected.
BITMD	6309	H=• N=• Z=↕ V=• C=•	Bit Test with MD	CC.Z' ← (MD.IL ∩ I.6=0) ∩ (MD./0 ∩ I.7=0), MD.IL' ← MD.IL ∩ not I.6, MD./0 ← MD.0 ∩ not I.7	Logical AND of the two most-significant bits of MD and the immediate value and modifies the Z condition code accordingly. The bits of the register MD are cleared if the corresponding bit in the immediate value is 1.
BOR	6309	H=• N=• Z=• V=• C=•	Logical OR Register Bit with Memory Bit into Register Bit	R.d' ← R.d ∪ DPM.s	Perform an logical OR the bit d of R and the bit s of the direct addressed memory byte into bit d of R.
CLR	6809	H=• N=0 Z=1 V=0 C=0	Clear Memory Byte	TEMP ← M, M' ← $00	The memory byte is loaded with $00.!!**The effective address is read during this operation.**
CLRA	6809	H=• N=0 Z=1 V=0 C=0	Clear A	A' ← $00	A is loaded with $00.
CLRB	6809	H=• N=0 Z=1 V=0 C=0	Clear B	B' ← $00	B is loaded with $00.
CLRD	6309	H=• N=0 Z=1 V=0 C=0	Clear D	D' ← $0000	D is loaded with $0000.
CLRE	6309	H=• N=0 Z=1 V=0 C=0	Clear E	E' ← $00	E is loaded with $00.
CLRF	6309	H=• N=0 Z=1 V=0 C=0	Clear F	F' ← $00	F is loaded with $00.
CLRW	6309	H=• N=0 Z=1 V=0 C=0	Clear W	W' ← $0000	W is loaded with $0000.
CMPA	6809	H=? N=↕ Z=↕ V=↕ C=↕	Compare Memory Byte from A	TEMP ← A - M	Compare the memory byte to A and sets the appropriate condition codes. Neither the memory byte nor A is modified. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry.!!The value of the H (half-carry) bit is undefined.
CMPB	6809	H=? N=↕ Z=↕ V=↕ C=↕	Compare Memory Byte from B	TEMP ← B - M	Compare the memory byte to B and sets the appropriate condition codes. Neither the memory byte nor B is modified. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry.!!The value of the H (half-carry) bit is undefined.
CMPD	6809	H=• N=↕ Z=↕ V=↕ C=↕	Compare Memory Word from D	TEMP ← D - M:M+1	Compare the memory byte to D and sets the appropriate condition codes. Neither the memory byte nor D is modified. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry.
CMPE	6309	H=? N=↕ Z=↕ V=↕ C=↕	Compare Memory Byte from E	TEMP ← E - M	Compare the memory byte to E and sets the appropriate condition codes. Neither the memory byte nor E is modified. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry.!!The value of the H (half-carry) bit is undefined.
CMPF	6309	H=? N=↕ Z=↕ V=↕ C=↕	Compare Memory Byte from F	TEMP ← F - M	Compare the memory byte to F and sets the appropriate condition codes. Neither the memory byte nor F is modified. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry.!!The value of the H (half-carry) bit is undefined.
CMPW	6309	H=• N=↕ Z=↕ V=↕ C=↕	Compare Memory Word from W	TEMP ← W - M:M+1	Compare the memory byte to W and sets the appropriate condition codes. Neither the memory byte nor W is modified. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry.
CMPX	6809	H=• N=↕ Z=↕ V=↕ C=↕	Compare Memory Word from X	TEMP ← X - M:M+1	Compare the memory byte to X and sets the appropriate condition codes. Neither the memory byte nor X is modified. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry.
CMPY	6809	H=• N=↕ Z=↕ V=↕ C=↕	Compare Memory Word from Y	TEMP ← Y - M:M+1	Compare the memory byte to Y and sets the appropriate condition codes. Neither the memory byte nor Y is modified. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry.
CMPS	6809	H=• N=↕ Z=↕ V=↕ C=↕	Compare Memory Word from S	TEMP ← S - M:M+1	Compare the memory byte to S and sets the appropriate condition codes. Neither the memory byte nor S is modified. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry.
CMPU	6809	H=• N=↕ Z=↕ V=↕ C=↕	Compare Memory Word from U	TEMP ← U - M:M+1	Compare the memory byte to U and sets the appropriate condition codes. Neither the memory byte nor U is modified. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry.
CMPR	6309	H=• N=↕ Z=↕ V=↕ C=↕	Compare Register from Register	TEMP ← R₁ - R₀	Compares R₁ to R₀ and sets the appropriate condition codes. Neither register is modified. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry.
COM	6809	H=• N=↕ Z=↕ V=0 C=1	Complement Memory Byte	M' ← 0 + M̅	Replace the memory byte with its logical complement. When operating on unsigned values, only BEQ and BNE branches can be expected to behave properly following a COM instruction. When operating on two's complement values, all signed branches are available.
COMA	6809	H=• N=↕ Z=↕ V=0 C=1	Complement A	A' ← 0 + A̅	Replace the contents of A with its logical complement. When operating on unsigned values, only BEQ and BNE branches can be expected to behave properly following a COM instruction. When operating on two's complement values, all signed branches are available.
COMB	6809	H=• N=↕ Z=↕ V=0 C=1	Complement B	B' ← 0 + B̅	Replace the contents of B with its logical complement. When operating on unsigned values, only BEQ and BNE branches can be expected to behave properly following a COM instruction. When operating on two's complement values, all signed branches are available.
COMD	6309	H=• N=↕ Z=↕ V=0 C=1	Complement D	D' ← 0 + D̅	Replace the contents of D with its logical complement. When operating on unsigned values, only BEQ and BNE branches can be expected to behave properly following a COM instruction. When operating on two's complement values, all signed branches are available.
COME	6309	H=• N=↕ Z=↕ V=0 C=1	Complement E	E' ← 0 + E̅	Replace the contents of E with its logical complement. When operating on unsigned values, only BEQ and BNE branches can be expected to behave properly following a COM instruction. When operating on two's complement values, all signed branches are available.
COMF	6309	H=• N=↕ Z=↕ V=0 C=1	Complement F	F' ← 0 + F̅	Replace the contents of F with its logical complement. When operating on unsigned values, only BEQ and BNE branches can be expected to behave properly following a COM instruction. When operating on two's complement values, all signed branches are available.
COMW	6309	H=• N=↕ Z=↕ V=0 C=1	Complement W	W' ← 0 + W̅	Replace the contents of W with its logical complement. When operating on unsigned values, only BEQ and BNE branches can be expected to behave properly following a COM instruction. When operating on two's complement values, all signed branches are available.
CWAI	6809	H=↕ N=↕ Z=↕ V=↕ C=↕	Clear CC bits and Wait for Interrupt	CC' ← CC ∩ I, E ← 1, S' ← S - 12, [S] ← PC ← U ← Y ← X ← DP ← [MD.NM = 1: F ⇠ E] ← B ← A ← CC	This instruction ANDs the immediate byte with the condition code register which may clear the interrupt mask bits I and F, stacks the entire machine state on the hardware stack and then looks for an interrupt. When a non-masked interrupt occurs, no further machine state information need be saved before vectoring to the interrupt handling routine. This instruction does not place the buses in a high-impedance state. A F̅I̅R̅Q̅ (fast interrupt request) may enter its interrupt handler with its entire machine state saved. The RTI (return from interrupt) instruction will automatically return the entire machine state after testing the E (entire) bit of the recovered condition code register.!!These immediate values will have the following results:  !$FF=enable neither, $EF=enable I̅R̅Q̅, $BF=enable F̅I̅R̅Q̅, $AF=enable both
DAA	6809	H=• N=↕ Z=↕ V=0 C=↕	Decimal Addition Adjust	A' ← A + CF(MSN):CF(LSN)	CF is the Correction Factor, where the CF for each nibble (BCD) digit is determined separately, and is either 6 or 0.!!**Least Significant Nibble**!!| | |!| ---: | :---|!| CF(LSN)=6 if |  1) C=1 |!| or | 2) LSN>9 |!!**Most Significant Nibble**!!| | |!| ---: | :---|!| CF(MSN)=6 if | 1) C=1 |!| or | 2) MSN > 9 |!| or | 3) MSN > 8 *and* LSN > 9 |!!The sequence of a single-byte add instruction on A (either ADDA or ADCA) and a following decimal addition adjust instruction results in a BCD addition with an appropriate C (carry) bit. Both values to be added must be in proper BCD form (each nibble such that: 0 < nibble < 9). Multiple-precision addition must add the carry generated by this decimal addition adjust into the next higher digit during the add operation (ADCA) immediately prior to the next decimal addition adjust.
DEC	6809	H=• N=↕ Z=↕ V=↕ C=•	Decrement Memory Byte	M' ← M - 1	Subtract one from the memory byte. The C (carry) bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only BEQ and BNE branches can be expected to behave consistently. When operating on two's complement values, all signed branches are available.
DECA	6809	H=• N=↕ Z=↕ V=↕ C=•	Decrement A	A' ← A - 1	Subtract one from A. The C (carry) bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only BEQ and BNE branches can be expected to behave consistently. When operating on two's complement values, all signed branches are available.
DECB	6809	H=• N=↕ Z=↕ V=↕ C=•	Decrement B	B' ← B - 1	Subtract one from B. The C (carry) bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only BEQ and BNE branches can be expected to behave consistently. When operating on two's complement values, all signed branches are available.
DECD	6309	H=• N=↕ Z=↕ V=↕ C=•	Decrement D	D' ← D - 1	Subtract one from C. The C (carry) bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only BEQ and BNE branches can be expected to behave consistently. When operating on two's complement values, all signed branches are available.
DECE	6309	H=• N=↕ Z=↕ V=↕ C=•	Decrement E	E' ← E - 1	Subtract one from E. The C (carry) bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only BEQ and BNE branches can be expected to behave consistently. When operating on two's complement values, all signed branches are available.
DECF	6309	H=• N=↕ Z=↕ V=↕ C=•	Decrement F	F' ← F - 1	Subtract one from F. The C (carry) bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only BEQ and BNE branches can be expected to behave consistently. When operating on two's complement values, all signed branches are available.
DECW	6309	H=• N=↕ Z=↕ V=↕ C=•	Decrement W	W' ← W - 1	Subtract one from W. The C (carry) bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only BEQ and BNE branches can be expected to behave consistently. When operating on two's complement values, all signed branches are available.
DIVD	6309	H=• N=↕ Z=↕ V=↕ C=↕	Signed Divide D by Memory Byte	B' ← D ÷ M, A' ← D mod M	Divide the signed contents of D (dividend) by the memory byte (divisor) and place the quotient into B and the remainder in A. The sign of the remainder is always the same as the sign of the dividend unless the remainder is zero. If the memory byte is zero, a Division-By-Zero exception is triggered (set bit 7 of MD, push the state onto the hardware stack, and jump to the illegal instruction vector).
DIVQ	6309	H=• N=↕ Z=↕ V=↕ C=↕	Signed Divide Q by Memory Word	W' ← Q ÷ M:M+1, D' ← Q mod M:M+1	Divide the signed contents of Q (dividend) by the memory word (divisor) and place the quotient into W and the remainder in D. The sign of the remainder is always the same as the sign of the dividend unless the remainder is zero. If the memory word is zero, a Division-By-Zero exception is triggered (set bit 7 of MD, push the state onto the hardware stack, and jump to the illegal instruction vector).
EIM	6309	H=• N=↕ Z=↕ V=0 C=•	Logical EOR of Immediate Byte into Memory Eyte	M' ← M ⊕ I	The immediate byte is exclusive ORed into the memory byte.
EORA	6809	H=• N=↕ Z=↕ V=0 C=•	Exclusive OR Memory Byte into A	A' ← A ⊕ M	The memory byte is exclusive ORed into A.
EORB	6809	H=• N=↕ Z=↕ V=0 C=•	Exclusive OR Memory Byte into B	B' ← B ⊕ M	The memory byte is exclusive ORed into B.
EORD	6309	H=• N=↕ Z=↕ V=0 C=•	Exclusive OR Memory Word into D	D' ← D ⊕ M:M+1	The memory word is exclusive ORed into D.
EORR	6309	H=• N=↕ Z=↕ V=0 C=•	Exclusive OR Register into Register	R₁' ← R₀ ⊕ R₁	 R₀ is exclusive ORed into R₁.
EXG	6809	H=• N=• Z=• V=• C=•	Exchange Registers	R₁ ↔ R2	Exchange data between two designated registers. Only like-size registers may be exchanged (8-bit with 8-bit or 16-bit with 16-bit).
INC	6809	H=• N=↕ Z=↕ V=↕ C=•	Increment Memory Byte	M' ← M + 1	Add one to the memory byte. The C (carry) bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only the BEQ and BNE branches can be expected to behave consistently. When operating on two's complement values, all signed branches are correctly available.
INCA	6809	H=• N=↕ Z=↕ V=↕ C=•	Increment A	A' ← A + 1	Add one to A. The C (carry) bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only the BEQ and BNE branches can be expected to behave consistently. When operating on two's complement values, all signed branches are correctly available.
INCB	6809	H=• N=↕ Z=↕ V=↕ C=•	Increment B	B' ← B + 1	Add one to B. The C (carry) bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only the BEQ and BNE branches can be expected to behave consistently. When operating on two's complement values, all signed branches are correctly available.
INCD	6309	H=• N=↕ Z=↕ V=↕ C=•	Increment D	D' ← D + 1	Add one to D. The C (carry) bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only the BEQ and BNE branches can be expected to behave consistently. When operating on two's complement values, all signed branches are correctly available.
INCE	6309	H=• N=↕ Z=↕ V=↕ C=•	Increment E	E' ← E + 1	Add one to E. The C (carry) bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only the BEQ and BNE branches can be expected to behave consistently. When operating on two's complement values, all signed branches are correctly available.
INCF	6309	H=• N=↕ Z=↕ V=↕ C=•	Increment F	F' ← F + 1	Add one to F. The C (carry) bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only the BEQ and BNE branches can be expected to behave consistently. When operating on two's complement values, all signed branches are correctly available.
INCW	6309	H=• N=↕ Z=↕ V=↕ C=•	Increment W	W' ← W + 1	Add one to W. The C (carry) bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only the BEQ and BNE branches can be expected to behave consistently. When operating on two's complement values, all signed branches are correctly available.
JMP	6809	H=• N=• Z=• V=• C=•	Jump	PC' ← EA	Program control is transferred to the effective address.
JSR	6809	H=• N=• Z=• V=• C=•	Jump to Subroutine	S' ← S - 2, [S]' ← PC, PC' ← EA	Program control is transferred to the effective address after storing the return address on the hardware stack. A RTS instruction should be the last executed instruction of the subroutine.
LBCC	6809	H=• N=• Z=• V=• C=•	Long Branch if Carry Clear (C=0), Equivalent to LBHS (Unsigned)	If C=0 then PC' ← PC + I	Test the state of the C (carry) bit and causes a branch if it is clear.!!*Equivalent to LBHS.*
LBCS	6809	H=• N=• Z=• V=• C=•	Long Branch if Carry Set (C=1), Equivalent to LBLO (Unsigned)	If C=1 then PC' ← PC + I	Test the state of the C (carry) bit and causes a branch If it is set.!!*Equivalent to LBLO.*
LBEQ	6809	H=• N=• Z=• V=• C=•	Long Branch if Equal (Z=1)	If Z=1 then PC' ← PC + I	Test the state of the Z (zero) bit and causes a branch if it is set. When used after a subtract or compare operation, this instruction will branch If the compared values, signed or unsigned, were exactly the same.
LBGE	6809	H=• N=• Z=• V=• C=•	Long Branch if Greater Than or Equal to Zero (Z=1 or N XOR V=0) (Signed)	If [N ⊕ V]=0 then PC' ← PC + I	Causes a branch if the N (negative) bit and the V (overflow) bit are either both set or both clear. That is, branch if the sign of a valid two's complement result is, or would be, positive. When used after a subtract or compare operation on two's complement values, this instruction will branch if the register was greater than or equal to the memory operand.
LBGT	6809	H=• N=• Z=• V=• C=•	Long Branch if Greater (N XOR V=0) (Signed)	If Z ∩ [N ⊕ V]=0 then PC' ← PC + I	Causes a branch if the N (negative) bit and V (overflow) bit are either both set or both clear and the Z (zero) bit is clear. In other words, branch if the sign of a valid two's complement result is, or would be, positive and not zero. When used after a subtract or compare operation on two's complement values, this instruction will branch if the register was greater than the memory operand.
LBHI	6809	H=• N=• Z=• V=• C=•	Long Branch if Higher (Z=0 AND C=0) (Unsigned)	If [C ∪ Z]=0 then PC' ← PC + I	Causes a branch if the previous operation caused neither a carry nor a zero result. When used after a subtract or compare operation on unsigned binary values, this instruction will branch if the register was higher than the memory operand.!!Generally not useful after INC/DEC, LD/TST, and TST/CLR/COM instructions.
LBHS	6809	H=• N=• Z=• V=• C=•	Long Branch if Higher or Same (C=0), Equivalent to LBCC (Unsigned)	If C=0 then PC' ← PC + I	Test the state of the C (carry) bit and causes a branch if it is clear. When used after a subtract or compare on unsigned binary values, this instruction will branch if the register was higher than or the same as the memory operand.!!This is a duplicate assembly-language mnemonic for the single machine instruction LBCC. Generally not useful after INC/DEC, LD/ST, and TST/CLR/COM instructions.!!*Equivalent to LBCC.*
LBLE	6809	H=• N=• Z=• V=• C=•	Long Branch if Less than or Equal to Zero (Z=1 or N XOR V=0) (Signed)	If Z ∪ [N ⊕ V]=0 then PC' ← PC + I	Causes a branch if the exclusive OR of the N (negative) and V (overflow) bits is 1 or if the Z (zero) bit is set. That is, branch if the sign of a valid two's complement result is, or would be, negative. When used after a subtract or compare operation on two's complement values, this instruction will branch if the register was less than or equal to the memory operand.
LBLO	6809	H=• N=• Z=• V=• C=•	Long Branch if Lower (C=1), Equivalent to LBCS (Unsigned)	If C=1 then PC' ← PC + I	Test the state of the C (carry) bit and causes a branch if it is set. When used after a subtract or compare on unsigned binary values, this instruction will branch if the register was lower than the memory operand.!!This is a duplicate assembly-language mnemonic for the single machine instruction LBCS. Generally not useful after INC/DEC.!!*Equivalent to LBCS.*
LBLS	6809	H=• N=• Z=• V=• C=•	Long Branch if Lower or Same (Z=1 or C=1) (Unsigned)	If [C ∪ Z]=1 then PC' ← PC + I	Causes a branch if the previous operation caused either a carry or a zero result. When used after a subtract or compare operation on unsigned binary values, this instruction will branch if the register was lower than or the same as the memory operand.!!Generally not useful after INC/DEC, LD/ST, and TST/CLR/COM instructions.
LBLT	6809	H=• N=• Z=• V=• C=•	Long Branch if Less than Zero (N XOR V=1) (Signed)	If [N ⊕ V]=1 then PC' ← PC + I	Causes a branch if either, but not both, of the N (negative) or V (overflow) bits is set. That is, branch if the sign of a valid two's complement result is, or would be, negative. When used after a subtract or compare operation on two's complement binary values, this instruction will branch if the register was less than the memory operand.
LBMI	6809	H=• N=• Z=• V=• C=•	Long Branch if Minus (N=1)	If N=1 then PC' ← PC + I	Test the state of the N (negative) bit and causes a branch if set. That is, branch if the sign of the two's compiement result is negative.!!When used after an operation on signed binary values, this instruction will branch if the result is minus. It is generally preferred to use the LBLT instruction after signed operations.
LBNE	6809	H=• N=• Z=• V=• C=•	Long Branch Not Equal (Z=0)	If Z=0 then PC' ← PC + I	Test the state of the Z (zero) bit and causes a branch if it is clear. When used after a subtract or compare operation on any binary values, this instruction will branch if the register is, or would be, not equal to the memory operand.
LBPL	6809	H=• N=• Z=• V=• C=•	Long Branch if Plus (N=0)	If N=0 then PC' ← PC + I	Test the state of the N (negative) bit and causes a branch if it is clear. That is, branch if the sign of the two's complement result is positive.!!When used after an operation on signed binary values, this instruction will branch if the result (possibly invalid) is positive. It is generally preferred to use the LBGE instruction after signed operations.
LBRA	6809	H=• N=• Z=• V=• C=•	Long Branch Always	PC' ← PC + I	Causes an unconditional branch.
LBRN	6809	H=• N=• Z=• V=• C=•	Long Branch Never (NOP)	NOP	Does not cause a branch. This instruction is essentially a no operation, but has a bit pattern logically related to branch always.
LBSR	6809	H=• N=• Z=• V=• C=•	Long Branch to Subroutine	S' ← S - 2, [S]' ← PC, PC' ← PC + I	The program counter is pushed onto the stack. The program counter is then loaded with the sum of the program counter and the offset.!!A return from subroutine (RTS) instruction is used to reverse this process and must be the last instruction executed in a subroutine.
LBVC	6809	H=• N=• Z=• V=• C=•	Long Branch if valid two's complement result (V=0)	If V=0 then PC' ← PC + I	Test the state of the V (overflow) bit and causes a branch if it is clear. That is, branch if the two's complement result was valid. When used after an operation on two's complement binary values, this instruction will branch if there was no overflow.
LBVS	6809	H=• N=• Z=• V=• C=•	Long Branch if invalid two's complement result (V=1)	If V=1 then PC' ← PC + I	Test the state of the V (overflow) bit and causes a branch if it is set. That is, branch if the two's complement result was invalid. When used after an operation on two's complement binary values, this instruction will branch if there was an overflow.
LDA	6809	H=• N=↕ Z=↕ V=0 C=•	Load A from Memory Byte	A' ← M	Load the memory byte into A.
LDB	6809	H=• N=↕ Z=↕ V=0 C=•	Load B from Memory Byte	B' ← M	Load the memory byte into B.
LDD	6309	H=• N=↕ Z=↕ V=0 C=•	Load D from Memory Word	D' ← M:M+1	Load the memory word into D. 
LDE	6309	H=• N=↕ Z=↕ V=0 C=•	Load E from Memory Byte	E' ← M	Load the memory byte into E.
LDF	6309	H=• N=↕ Z=↕ V=0 C=•	Load F from Memory Byte	F' ← M	Load the memory byte into F.
LDW	6309	H=• N=↕ Z=↕ V=0 C=•	Load W from Memory Word	W' ← M:M+1	Load the memory word into W.
LDX	6809	H=• N=↕ Z=↕ V=0 C=•	Load X from Memory Word	X' ← M:M+1	Load the memory word into X.
LDY	6809	H=• N=↕ Z=↕ V=0 C=•	Load Y from Memory Word	Y' ← M:M+1	Load the memory word into Y.
LDS	6809	H=• N=↕ Z=↕ V=0 C=•	Load S from Memory Word	S' ← M:M+1	Load the memory word into S.
LDU	6809	H=• N=↕ Z=↕ V=0 C=•	Load U from Memory Word	U' ← M:M+1	Load the memory word into U.
LDBT	6309	H=• N=• Z=• V=• C=•	Load Register Bit from Memory Byte	R.d' ← DPM.s	Load bit s of the direct address memory byte into bit d of R. No condition codes are affected.
LDMD	6309	H=• N=• Z=• V=• C=•	Load Immediate Byte into MD	MD.NM' ← I.0, MD.FM ← I.1	Load the native mode and FIRQ mode bits (two least-significant bits) of the immediate byte into MD. No condition codes are affected.
LDQ	6309	H=• N=↕ Z=↕ V=0 C=•	Load Q from Memory Quad	Q' ← M:M+3	Load the memory quad into Q.
LEAX	6809	H=• N=• Z=↕ V=• C=•	Load Effective Address into X	X' ← EA	Calculate the effective address from the indexed addressing and places the address in X.!!LEAX affects the Z (zero) bit to allow use of these registers as counters.!!Due to the order in which effective addresses are calculated internally, the LEAX ,X++ and LEAX ,X+ **do not add 2 and 1 (respectively) to the X register**, but instead leave the X register unchanged. This also applies to the Y, U, and S registers. For the expected results, use the faster instruction LEAX 2,X and LEAX 1,X.!!Some examples of LEA instruction uses are given in the following table.!!| instruction | Operation | Comment |!| :--- | :--- | :--- |!| LEAX 10,X | X + 10 → X | Adds 5-bit constant 10 to X |!| LEAX 500,X | X + 500 → X | Adds 16-bit constant 500 to X |!| LEAX A,X | X + A → X | Adds 8-bit A to X |!| LEAX D,X | X + D → X | Adds 16-bit D to X |!| LEAX -10,X | X - 10 → X | Subtracts 10 from X |
LEAY	6809	H=• N=• Z=↕ V=• C=•	Load Effective Address into Y	Y' ← EA	Calculate the effective address from the indexed addressing and places the address in Y.!!LEAY affects the Z (zero) bit to allow use of these registers as counters.!!Due to the order in which effective addresses are calculated internally, the LEAX ,Y++ and LEAX ,Y+ **do not add 2 and 1 (respectively) to the Y register**, but instead leave the Y register unchanged. This also applies to the X, U, and S registers. For the expected results, use the faster instruction LEAY 2,X and LEAY 1,X.!!Some examples of LEA instruction uses are given in the following table.!!| instruction | Operation | Comment |!| :--- | :--- | :--- |!| LEAY 10,Y | Y + 10 → Y | Adds 5-bit constant 10 to Y |!| LEAY 500,Y | Y + 500 → Y | Adds 16-bit constant 500 to Y |!| LEAY A,Y | Y + A → Y | Adds 8-bit A to Y |!| LEAY D,Y | Y + D → Y | Adds 16-bit D accumulator to Y |!| LEAY -10,Y | Y - 10 → Y | Subtracts 10 from Y |
LEAS	6809	H=• N=• Z=• V=• C=•	Load Effective Address into S	S' ← EA	Calculate the effective address from the indexed addressing and places the address in S.!!LEAS does not affect the Z (zero) bit to allow cleaning up the stack while returning the Z (zero) bit as a parameter to a calling routine.!!Due to the order in which effective addresses are calculated internally, the LEAS ,S++ and LEAS ,S+ **do not add 2 and 1 (respectively) to the S register**, but instead leave the S register unchanged. This also applies to the X, Y, and U registers. For the expected results, use the faster instruction LEAS 2,S and LEAX 1,S.!!Some examples of LEA instruction uses are given in the following table.!!| instruction | Operation | Comment |!| :--- | :--- | :--- |!| LEAS 10,S | S + 10 → S | Adds 5-bit constant 10 to S |!| LEAS 500,S | S + 500 → S | Adds 16-bit constant 500 to S |!| LEAS A,S | S + A → S | Adds 8-bit accumulator to S |!| LEAS D,S | S + D → S | Adds 16-bit D accumulator to S |!| LEAS -10,S | S - 10 → S | Subtracts 10 from S |!| LEAS -10,S | S - 10 → S | Used to reserve area on the hardware stack |!| LEAS 10,S | S + 10 → S | Used to 'clean up' the hardware stack |!| LEAX 5,S | S + 5 → X | Transfers as well as adds |
LEAU	6809	H=• N=• Z=• V=• C=•	Load Effective Address into U	U' ← EA	Calculate the effective address from the indexed addressing and places the address in U.!!LEAU does not affect the Z (zero) bit to allow cleaning up the stack while returning the Z (zero) bit as a parameter to a calling routine.!!Due to the order in which effective addresses are calculated internally, the LEAU ,U++ and LEAU ,U+ **do not add 2 and 1 (respectively) to the U register**, but instead leave the U register unchanged. This also applies to the X, Y, and S registers. For the expected results, use the faster instruction LEAU 2,U and LEAX 1,U.!!Some examples of LEA instruction uses are given in the following table.!!| instruction | Operation | Comment |!| :--- | :--- | :--- |!| LEAU 10,U | U + 10 → U | Adds 5-bit constant 10 to U |!| LEAU 500,U | U + 500 → U | Adds 16-bit constant 500 to U |!| LEAU A,U | U + A → U | Adds 8-bit accumulator to U |!| LEAU D,U | U + D → U | Adds 16-bit D accumulator to U |!| LEAU -10,U | U - 10 → U | Subtracts 10 from U |!| LEAU -10,U | U - 10 → U | Used to reserve area on the user stack |!| LEAU 10,U | U + 10 → U | Used to 'clean up' the user stack |!| LEAX 5,U | U + 5 → X | Transfers as well as adds |
LSL	6809	H=• N=↕ Z=↕ V=↕ C=↕	Logical Shift Left of Memory Byte, Equivalant of ASL	'C ←□□□□□□□□← 0	Shift all bits of the memory byte one place to the left. Bit zero is loaded with a zero. Bit seven of the memory byte is shifted into the C (carry) bit.!!*This is a duplicate assembly-language mnemonic for the single machine instruction ASL.*
LSLA	6809	H=• N=↕ Z=↕ V=↕ C=↕	Logical Shift Left of A, Equivalant of ASLA	C ←□□□□□□□□← 0	Shift all bits of A one place to the left. Bit zero is loaded with a zero. Bit seven of A is shifted into the C (carry) bit.!!*This is a duplicate assembly-language mnemonic for the single machine instruction ASLA.*
LSLB	6809	H=• N=↕ Z=↕ V=↕ C=↕	Logical Shift Left of B, Equivalant of ASLB	C ←□□□□□□□□← 0	Shift all bits of B one place to the left. Bit zero is loaded with a zero. Bit seven of B is shifted into the C (carry) bit.!!*This is a duplicate assembly-language mnemonic for the single machine instruction ASLB.*
LSLD	6309	H=• N=↕ Z=↕ V=↕ C=↕	Logical Shift Left of D, Equivalant of ASLC	C ←□□□□□□□□□□□□□□□□← 0	Shift all bits of D one place to the left. Bit zero is loaded with a zero. Bit fifteen of D is shifted into the C (carry) bit.!!*This is a duplicate assembly-language mnemonic for the single machine instruction ASLD.*
LSR	6809	H=• N=0 Z=↕ V=• C=↕	Logical Shift Right of Memory Byte	0 →□□□□□□□□→ C	Perform a logical shift right on the memory byte. Shifts a zero into bit seven and bit zero into the C (carry) bit.
LSRA	6809	H=• N=0 Z=↕ V=• C=↕	Logical Shift Right of A	0 →□□□□□□□□→ C	Perform a logical shift right on A. Shifts a zero into bit seven and bit zero into the C (carry) bit.
LSRB	6809	H=• N=0 Z=↕ V=• C=↕	Logical Shift Right of B	0 →□□□□□□□□→ C	Perform a logical shift right on B. Shifts a zero into bit seven and bit zero into the C (carry) bit.
LSRD	6309	H=• N=0 Z=↕ V=• C=↕	Logical Shift Right of D	0 →□□□□□□□□□□□□□□□□→ C	Perform a logical shift right on D. Shifts a zero into bit fifteen and bit zero into the C (carry) bit.
LSRW	6309	H=• N=0 Z=↕ V=• C=↕	Logical Shift Right of W	0 →□□□□□□□□□□□□□□□□→ C	Perform a logical shift right on W. Shifts a zero into bit fifteen and bit zero into the C (carry) bit.
MUL	6809	H=• N=• Z=↕ V=• C=†	Unsigned Multiply into D	D' ← A × B	Multiply A and B, place the result in D. Unsigned multiply allows multiple-precision operations.!!† The C (carry) bit is set if bit 7 is set and allows rounding the most-significant byte through the sequence: MUL, ADCA #0.
MULD	6309	H=• N=↕ Z=↕ V=• C=•	Signed Multiply into Q	Q' ← D × I|M:M+1	Multiply D and the specified immediate word or memory word and place the result in Q.
NEG	6809	H=? N=↕ Z=↕ V=↕ C=↕	Negate Memory Byte	M' ← 0 - M	Replace the memory byte with its two's complement. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry. Note that $0080 is replaced by itself and **only in this case is the V (overflow) bit set**. The value $0000 is also replaced by itself, and **only in this case is the C (carry) bit cleared**.!!The resultant value of the H (half-carry) bit is undefined.
NEGA	6809	H=? N=↕ Z=↕ V=↕ C=↕	Negate A	A' ← 0 - A	Replace A with its two's complement. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry. Note that $0080 is replaced by itself and **only in this case is the V (overflow) bit set**. The value $0000 is also replaced by itself, and **only in this case is the C (carry) bit cleared**.!!The resultant value of the H (half-carry) bit is undefined.
NEGB	6809	H=? N=↕ Z=↕ V=↕ C=↕	Negate B	B' ← 0 - B	Replace B with its two's complement. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry. Note that $0080 is replaced by itself and **only in this case is the V (overflow) bit set**. The value $0000 is also replaced by itself, and **only in this case is the C (carry) bit cleared**.!!The resultant value of the H (half-carry) bit is undefined.
NEGD	6809	H=• N=↕ Z=↕ V=↕ C=↕	Negate D	D' ← 0 - D	Replace D with its two's complement. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry. Note that $8000 is replaced by itself and **only in this case is the V (overflow) bit set**. The value $0000 is also replaced by itself, and **only in this case is the C (carry) bit cleared**.
NOP	6809	H=• N=• Z=• V=• C=•	No Operation	NOP	This instruction causes only the program counter to be incremented. No other registers or memory locations are affected.
OIM	6309	H=• N=↕ Z=↕ V=0 C=•	Logical OR Immediate Byte into Memory Byte	M' ← M ∪ I	Perform an inclusive OR the memory byte and the immediate byte and store into the memory byte.
ORA	6809	H=• N=↕ Z=↕ V=0 C=•	Inclusive OR Memory Byte into A	A' ← A ∪ M	Perform an inclusive OR of A and the memory byte and store the result into A.
ORB	6809	H=• N=↕ Z=↕ V=0 C=•	Inclusive OR Memory Byte into B	B' ← B ∪ M	Perform an inclusive OR of B and the memory byte and store the result into B.
ORCC	6809	H=↕ N=↕ Z=↕ V=↕ C=↕	Inclusive OR Immediate Byte into CC	CC'— CC ∪ IMM	Perform an inclusive OR of the condition code register and the immediate byte and store the result in the condition code register. This instruction may be used to set interrupt masks (disable interrupts) or any other bit(s).
ORD	6309	H=• N=↕ Z=↕ V=0 C=•	Inclusive OR Memory Word into D	D' ← D ∪ M:M+1	Perform an inclusive OR of D and the memory word and store the results into D.
ORR	6309	H=• N=↕ Z=↕ V=0 C=•	Inclusive OR Register into Register	R₁' ← R₁ ∪ R₀	Perform an inclusive OR of R₀ and R₁ and store the results into R₁.
PSHS	6809	H=• N=• Z=• V=• C=•	Push Registers onto Hardware Stack	PC ⇢ U ⇢ Y ⇢ X ⇢ DP ⇢ B ⇢ A ⇢ CC	All, some, or none of the processor registers are pushed onto the hardware stack (with the exception of the hardware stack pointer itself).!!A single register may be placed on the stack with the condition codes set by doing an autodecrement store onto the stack (example: STX ,--S).
PSHSW	6309	H=• N=• Z=• V=• C=•	Push W onto Hardware Stack	S' ← S - 2, [S:S+1]' ← W	Autodecrement the hardware stack register and pushs the value of the register W (E and F) onto the hardware stack. Condition codes are not affected.
PSHU	6809	H=• N=• Z=• V=• C=•	Push Registers onto User Stack	PC ⇢ S ⇢ Y ⇢ X ⇢ DP ⇢ B ⇢ A ⇢ CC	All, some, or none of the processor registers are pushed onto the user stack (with the exception of the user stack pointer itself).!!A single register may be placed on the stack with the condition codes set by doing an autodecrement store onto the stack (example: STX ,--U).
PSHUW	6309	H=• N=• Z=• V=• C=•	Push W onto User Stack	U' ← U - 2, [U:U+1]' ← W	Autodecrement the user stack register and pushs the value of the register W (E and F) onto the user stack. Condition codes are not affected.
PULS	6809	H=• N=• Z=• V=• C=•	Pull Registers from Hardware Stack	PC ⇠ U ⇠ Y ⇠ X ⇠ DP ⇠ B ⇠ A ⇠ CC	All, some, or none of the processor registers are pulled from the hardware stack (with the exception of the hardware stack pointer itself).!!A single register may be pulled from the stack with condition codes set by doing an autoincrement load from the stack (example: LDX ,S++).
PULSW	6309	H=• N=• Z=• V=• C=•	Pull W from Hardware Stack	W' ← S:S+1, S' ← S + 2	Pull the value for register W (E and F) from the hardware stack and autoincrements the hardware stack register. Condition codes are not affected.
PULU	6809	H=• N=• Z=• V=• C=•	Pull Registers from User Stack	PC ⇠ S ⇠ Y ⇠ X ⇠ DP ⇠ B ⇠ A ⇠ CC	All, some, or none of the processor registers are pulled from the user stack (with the exception of the user stack pointer itself).!!A single register may be pulled from the stack with condition codes set by doing an autoincrement load from the stack (example: LDX ,U++).
PULUW	6309	H=• N=• Z=• V=• C=•	Pull W from User Stack	W' ← [U:U+1], U' ← U + 2	Pull the value for register W (E and F) from the user stack and autoincrements the user stack register. Condition codes are not affected.
ROL	6809	H=• N=↕ Z=↕ V=↕ C=↕	Rotate Memory Byte Left	C ←□□□□□□□□← C	Rotate all bits of the memory byte one place left through the C (carry) bit. This is a 9-bit rotation.
ROLA	6809	H=• N=↕ Z=↕ V=↕ C=↕	Rotate A Left	C ←□□□□□□□□← C	Rotate all bits of A one place left through the C (carry) bit. This is a 9-bit rotation.
ROLB	6809	H=• N=↕ Z=↕ V=↕ C=↕	Rotate B Left	C ←□□□□□□□□← C	Rotate all bits of B one place left through the C (carry) bit. This is a 9-bit rotation.
ROLD	6309	H=• N=↕ Z=↕ V=↕ C=↕	Rotate D Left	C ←□□□□□□□□□□□□□□□□← C	Rotate all bits of D one place left through the bit. This is a 17-bit rotation.
ROLW	6309	H=• N=↕ Z=↕ V=↕ C=↕	Rotate W Left	C ←□□□□□□□□□□□□□□□□← C	Rotate all bits of W one place left through the bit. This is a 17-bit rotation.
ROR	6809	H=• N=↕ Z=↕ V=• C=↕	Rotate Memory Byte Right	C →□□□□□□□□→ C	Rotate all bits of the memory byte one place right through the C (carry) bit. This is a 9-bit rotation.
RORA	6809	H=• N=↕ Z=↕ V=• C=↕	Rotate A Right	C →□□□□□□□□→ C	Rotate all bits of the A one place right through the C (carry) bit. This is a 9-bit rotation.
RORB	6809	H=• N=↕ Z=↕ V=• C=↕	Rotate B Right	C →□□□□□□□□→ C	Rotate all bits of the B one place right through the C (carry) bit. This is a 9-bit rotation.
RORD	6309	H=• N=↕ Z=↕ V=• C=↕	Rotate D Right	C →□□□□□□□□□□□□□□□□→ C	Rotate all bits of D one place right through the C (carry) bit. This is a 17-bit rotation.
RORW	6309	H=• N=↕ Z=↕ V=• C=↕	Rotate W Right	C →□□□□□□□□□□□□□□□□→ C	Rotate all bits of W one place right through the C (carry) bit. This is a 17-bit rotation.
RTI	6809	H=↕ N=↕ Z=↕ V=↕ C=↕	Return from Interrupt	CC' ← [S], CC.E=0: PC' ← [S], CC.E=1: PC⇠U⇠Y⇠X⇠DP⇠[MD.NM=1: F⇠E]⇠B⇠A⇠CC ← [S], S' ← S + n	The saved machine state is recovered from the hardware stack and control is returned to the interrupted program. If the recovered E (entire) bit is clear, it indicates that only a subset of the machine state was saved (return address and condition codes) and only that subset is recovered.
RTS	6809	H=• N=• Z=• V=• C=•	Return from Subroutine	PC' ← [S], S' ← S + 2	Program control is returned from the subroutine to the calling program. The return address is pulled from the stack.
SBCA	6809	H=? N=↕ Z=↕ V=↕ C=↕	Subtract Memory Byte from A with Borrow	A' ← A - M - C	Subtract the memory byte and the borrow (in the C (carry) bit) from A and places the result in A. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry.!!The resultant value of the H (half-carry) bit is undefined.
SBCB	6809	H=? N=↕ Z=↕ V=↕ C=↕	Subtract Memory Byte from B with Borrow	B' ← B - M - C	Subtract the memory byte and the borrow (in the C (carry) bit) from B and places the result in B. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry.!!The resultant value of the H (half-carry) bit is undefined.
SBCD	6309	H=• N=↕ Z=↕ V=↕ C=↕	Subtract Memory Word from D with Borrow	D' ← D - M:M+1 - C	Subtract the memory word and the borrow (in the C (carry) bit) from D and places the result in D. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry.
SBCR	6309	H=• N=↕ Z=↕ V=↕ C=↕	Subtract Register from Register with Borrow	R₁' ← R₁ - R₀ - C	Subtract R₀ and the borrow (in the C (carry) bit) from R₁ and places the result in R₁. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry.
SEX	6809	H=• N=↕ Z=↕ V=0 C=•	Sign Extend B into D	If bit 7 of B is set then A' ← $FF else A' ← $00	This instruction transforms a two's complement 8-bit value in B into a two's complement 16-bit value in D.
SEXW	6309	H=• N=↕ Z=↕ V=• C=•	Sign Extend W into Q	If bit 15 of W is set then D' ← $FFFF else D' ← $0000	This instruction transforms a two's complement 16-bit value in W into a two's complement 32-bit value in the Q.
STA	6809	H=• N=↕ Z=↕ V=0 C=•	Store A into Memory Byte	M' ← A	Write the contents of A into the memory byte.
STB	6809	H=• N=↕ Z=↕ V=0 C=•	Store B into Memory Byte	M' ← B	Write the contents of B into the memory byte.
STE	6309	H=• N=↕ Z=↕ V=0 C=•	Store E into Memory Byte	M' ← E	Write the contents of E into the memory byte.
STF	6309	H=• N=↕ Z=↕ V=0 C=•	Store F into Memory Byte	M' ← F	Write the contents of F into the memory byte.
STD	6809	H=• N=↕ Z=↕ V=0 C=•	Store D into Memory Word	M':M'+1 ← D	Write the contents of D into the memory word.
STW	6309	H=• N=↕ Z=↕ V=0 C=•	Store W into Memory Word	M':M'+1 ← W	Write the contents of W into the memory word.
STX	6809	H=• N=↕ Z=↕ V=0 C=•	Store X into Memory Word	M':M'+1 ← X	Write the contents of X into the memory word.
STY	6809	H=• N=↕ Z=↕ V=0 C=•	Store Y into Memory Word	M':M'+1 ← Y	Write the contents of Y into the memory word.
STS	6809	H=• N=↕ Z=↕ V=0 C=•	Store S into Memory Word	M':M'+1 ← S	Write the contents of S into the memory word.
STU	6809	H=• N=↕ Z=↕ V=0 C=•	Store U into Memory Word	M':M'+1 ← U	Write the contents of U into the memory word.
STBT	6309	H=• N=• Z=• V=• C=•	Store Register Bit into Direct Page Memory Byte	DPM.d' ← R.s	Write bit s of register R into bit d in direct addressed memory location DPM.
STQ	6309	H=• N=↕ Z=↕ V=0 C=•	Store Q into Memory Quad	M':M'+3 ← Q	Write the contents of Q into the memory quad.
SUBA	6809	H=? N=↕ Z=↕ V=↕ C=↕	Subtract Memory Byte from A	A' ← A - M	Subtract the memory byte from A. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry.!!The resultant value of the H (half-carry) bit is undefined.
SUBB	6809	H=? N=↕ Z=↕ V=↕ C=↕	Subtract Memory Byte from B	B' ← B - M	Subtract the memory byte from B. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry.!!The resultant value of the H (half-carry) bit is undefined.
SUBE	6809	H=? N=↕ Z=↕ V=↕ C=↕	Subtract Memory Byte from E	E' ← E - M	Subtract the memory byte from E. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry.!!The resultant value of the H (half-carry) bit is undefined.
SUBF	6809	H=? N=↕ Z=↕ V=↕ C=↕	Subtract Memory Byte from F	F' ← F - M	Subtract the memory byte from F. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry.!!The resultant value of the H (half-carry) bit is undefined.
SUBD	6809	H=• N=↕ Z=↕ V=↕ C=↕	Subtract Memory Word from D	D' ← D - M:M+1	Subtract the memory word from D. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry.
SUBR	6309	H=• N=↕ Z=↕ V=↕ C=↕	Subtract Register from Register	R₁' ← R₁ - R₀	Subtract R₀ from R₁. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry.
SWI	6809	H=• N=• Z=• V=• C=•	Software Interrupt	CC.E' ← 1, S' ← S - 12, [S]'← PC⇠U⇠Y⇠X⇠DP⇠[MD.NM=1: F⇠E]⇠B⇠A⇠CC, CC.I' ← 1, CC.F' ← 1, PC' ← [$FFFA]:[$FFFB]	All of the processor registers are pushed onto the hardware stack (with the exception of the hardware stack pointer itself), and control is transferred through the software Interrupt vector. Both the normal and fast interrupts are masked (disabled).
SWI2	6809	H=• N=• Z=• V=• C=•	Software Interrupt 2	CC.E' ← 1, S' ← S - 12, [S]' ← PC⇠U⇠Y⇠X⇠DP⇠[MD.NM=1: F⇠E]⇠B⇠A⇠CC, CC.I' ← 1, CC.F' ← 1, PC' ← [$FFF4]:[$FFF5]	All of the processor registers are pushed onto the hardware stack (with the exception of the hardware stack pointer itself), and control is transferred through the software interrupt 2 vector. This interrupt is available to the end user and must not be used in packaged software. This interrupt does not mask (disable) the norma! and fast interrupts.
SWI3	6809	H=• N=• Z=• V=• C=•	Software Interrupt 3	CC.E' ← 1, S' ← S - 12, [S]' ← PC⇠U⇠Y⇠X⇠DP⇠[MD.NM=1: F⇠E]⇠B⇠A⇠CC, CC.I' ← 1, CC.F' ← 1, PC' ← [$FFF2]:[$FFF3]	All of the processor registers are pushed onto the hardware stack (with the exception of the hardware stack pointer itself), and control is transferred through the software interrupt 3 vector. This interrupt does not mask (disable) the normal and fast interrupts.
SYNC	6809	H=• N=• Z=• V=• C=•	Synchronize to External Event	SYNC	When a SYNC instruction is excuted, the processor enters a synchronizing state, stops processing instructions, and waits for an interrupt. When an interrupt occurs, the synchronizing state is cleared and processing continues. If the interrupt is enabled, and it lasts three cycles or more, the processor will perform the interrupt routine. If the interrupt is masked or is shorter than three cycles, the processor simply continues to the next instruction. While in the synchronizing state, the address and data buses are in the high-impedance state.!!This instruction provides software synchronization with a hardware process. Consider the following example for high-speed acquisition of data:!!```FAST   SYNC             WAIT FOR DATA!       Interrupt!!       LDA        DISC  DATA FROM DISC AND CLEAR INTERRUPT!       STA        ,X+   PUT IN BUFFER!       DECB             COUNT IT, DONE?!       BNE        FAST  GO AGAIN IF NOT.!```!!The synchronizing state is cleared by any interrupt. Of course, enabled interrupts at this point may destroy the data transfer and, as such, should represent only emergency conditions.!!The same connection used for interrupt-driven I/O service may also be used for high-speed data transfers by setting the interrupt mask and using the SYNC instruction as the above example demonstrates.
TFM	6309	H=• N=• Z=• V=• C=•	Transfer Memory	M':M'+W ← M:M+W	Transfer the number of bytes specified in W from the source memory locations to the destination memory locations.
TFR	6809	H=• N=• Z=• V=• C=•	Transfer Register to Register	R₀ → R₁'	Transfer data between two designated registers. Only like size registers may be transferred. (8-bit to 8-bit, or 16-bit to 16-bit.)
TIM	6309	H=• N=↕ Z=↕ V=0 C=•	Bit Test Immediate Byte with Memory Byte	TEMP ← M ∩ I	Logical AND of the memory byte and the intermediate byte and modifies the condition codes accordingly. The content of the memory byte is not affected.
TST	6809	H=• N=↕ Z=↕ V=0 C=•	Test Memory Byte	TEMP ← M - 0	Set the N (negative) and Z (zero) bits according to the contents of the memory byte and clear the V (overflow) bit. The TST instruction provides only minimum information when testing unsigned values, since no unsigned value is less than zero, BLO and BLS have no utility. While BHI could be used after TST, it provides exactly the same control as BNE, which is preferred. The signed branches are available.
TSTA	6809	H=• N=↕ Z=↕ V=0 C=•	Test A	TEMP ← A - 0	Set the N (negative) and Z (zero) bits according to A and clear the V (overflow) bit. The TST instruction provides only minimum information when testing unsigned values, since no unsigned value is less than zero, BLO and BLS have no utility. While BHI could be used after TST, it provides exactly the same control as BNE, which is preferred. The signed branches are available.
TSTB	6809	H=• N=↕ Z=↕ V=0 C=•	Test B	TEMP ← B - 0	Set the N (negative) and Z (zero) bits according to B and clear the V (overflow) bit. The TST instruction provides only minimum information when testing unsigned values, since no unsigned value is less than zero, BLO and BLS have no utility. While BHI could be used after TST, it provides exactly the same control as BNE, which is preferred. The signed branches are available.
TSTD	6309	H=• N=↕ Z=↕ V=0 C=•	Test D	TEMP ← D - 0	Set the N (negative) and Z (zero) bits according to D and clear the V (overflow) bit. The TST instruction provides only minimum information when testing unsigned values, since no unsigned value is less than zero, BLO and BLS have no utility. While BHI could be used after TST, it provides exactly the same control as BNE, which is preferred. The signed branches are available.
TSTE	6309	H=• N=↕ Z=↕ V=0 C=•	Test E	TEMP ← E - 0	Set the N (negative) and Z (zero) bits according to E and clear the V (overflow) bit. The TST instruction provides only minimum information when testing unsigned values, since no unsigned value is less than zero, BLO and BLS have no utility. While BHI could be used after TST, it provides exactly the same control as BNE, which is preferred. The signed branches are available.
TSTF	6309	H=• N=↕ Z=↕ V=0 C=•	Test F	TEMP ← F - 0	Set the N (negative) and Z (zero) bits according to F and clear the V (overflow) bit. The TST instruction provides only minimum information when testing unsigned values, since no unsigned value is less than zero, BLO and BLS have no utility. While BHI could be used after TST, it provides exactly the same control as BNE, which is preferred. The signed branches are available.
TSTW	6309	H=• N=↕ Z=↕ V=0 C=•	Test W	TEMP ← W - 0	Set the N (negative) and Z (zero) bits according to W and clear the V (overflow) bit. The TST instruction provides only minimum information when testing unsigned values, since no unsigned value is less than zero, BLO and BLS have no utility. While BHI could be used after TST, it provides exactly the same control as BNE, which is preferred. The signed branches are available.
