ABX;Add B into X (Unsigned);IX' ← IX + ACCB!!Add the 8-bit unsigned value in accumulator B into index register X.;6809
ADCA;Add Memory with Carry into A;R' ← R + M + C!!Adds the contents of the C (carry) bit and the memory byte into an 8-blt accumulator.;6809
ADCB;Add Memory with Carry into B;R' ← R + M + C!!Adds the contents of the C (carry) bit and the memory byte into an 8-blt accumulator.;6809
ADCD;Add Memory with Carry into D;R' ← R + M:M+1 + C!!Adds the contents of the C (carry) bit and the 16-bit memory value into the 16-blt accumulator.;6309
ADCR;Add Register with Carry into Register;R1' ← R1 + R0 + C!!Adds the contents of the C (carry) bit and the contents of register R0 into the register R1.;6309
ADDA;Add Memory into A;R' ← R + M!!Adds the memory byte into an 8-bit accumulator.;6809
ADDB;Add Memory into B;R' ← R + M!!Adds the memory byte into an 8-bit accumulator.;6809
ADDD;Add Memory into D;R' ← R + M:M+1!!Adds the 16-bit memory value into the 16-bit accumulator.;6809
ADDE;Add Memory into E;R' ← R + M!!Adds the memory byte into an 8-bit accumulator.;6309
ADDF;Add Memory into F;R' ← R + M!!Adds the memory byte into an 8-bit accumulator.;6309
ADDR;Add Register into Register;R1' ← R1 + R0!!Adds the contents of register R1 and the contents of register R0 into a register R1.;6309
ADDW;Add Memory into W;R' ← R + M:M+1!!Adds the 16-bit memory value into the 16-bit accumulator.;6309
AIM;Logical AND of Value with Memory;M' ← M ∩ I!!Performs the logical AND operation between the contents of memory location M and the immediate value and the result is stored in memory location M.;6309
ANDA;Logical AND Memory into A;R' ← R ∩ M!!Performs the logical AND operation between the contents of an accumulator and the contents of memory location M and the result is stored in the accumulator.;6809
ANDB;Logical AND Memory into B;R' ← R ∩ M!!Performs the logical AND operation between the contents of an accumulator and the contents of memory location M and the result is stored in the accumulator.;6809
ANDD;Logical AND Memory into D;R' ← R ∩ M:M+1!!Performs the logical AND operation between the contents of an accumulator and the contents of memory location M and the result is stored in the accumulator.;6309
ANDR;Logical AND Memory into R;R1' ← R1 ∩ R0!!Performs the logical AND operation between the contents of register R1 and the contents of register R0 and the result is stored in the register R1.;6309
ANDCC;Logical AND Memory into CC;R' ← R ∩ MI!!Performs a logical AND between the condition code register and the Immediate byte specified In the instruction and places the result in the condition code register.;6809
ASL;Arithmetic Memory Shift Left;C ←□□□□□□□□← 0!!Shifts all bits of the operand one place to the left. Bit zero is loaded with a zero. Bit seven is shifted into the C (carry) bit.;6809
ASLA;Arithmetic A Shift Left;C ←□□□□□□□□← 0!!Shifts all bits of the operand one place to the left. Bit zero is loaded with a zero. Bit seven is shifted into the C (carry) bit.;6809
ASLB;Arithmetic B Shift Left;C ←□□□□□□□□← 0!!Shifts all bits of the operand one place to the left. Bit zero is loaded with a zero. Bit seven is shifted into the C (carry) bit.;6809
ASLD;Arithmetic D Shift Left;C ←□□□□□□□□□□□□□□□□← 0!!Shifts all bits of the operand one place to the left. Bit zero is loaded with a zero. Bit fifteen is shifted into the C (carry) bit.;6309
ASR;Arithmetic Memory Shift Right;b7 →□□□□□□□□→ C!!Shifts all bits of the operand one place to the right. Bit seven is held constant. Bit zero is shifted into the C (carry) bit.;6809
ASRA;Arithmetic A Shift Right;b7 →□□□□□□□□→ C!!Shifts all bits of the operand one place to the right. Bit seven is held constant. Bit zero is shifted into the C (carry) bit.;6809
ASRB;Arithmetic B Shift Right;b7 →□□□□□□□□→ C!!Shifts all bits of the operand one place to the right. Bit seven is held constant. Bit zero is shifted into the C (carry) bit.;6809
ASRD;Arithmetic D Shift Right;b7 →□□□□□□□□□□□□□□□□→ C!!Shifts all bits of the operand one place to the right. Bit fifteen is held constant. Bit zero is shifted into the C (carry) bit.;6309
BCC;Branch if Carry Clear (C=0) (Unsigned);TEMP ← MI  !IFF C = 0 then PC' ← PC + TEMP!!Tests the state of the C (carry) bit and causes a branch If it Is clear.!!Equivalent to BHS.;6809
BCS;Branch if Carry Set (C=1) (Unsigned);TEMP ← MI  !IFF C = 1 then PC' ← PC + TEMP!!Tests the state of the C (carry) bit and causes a branch If it is set.!!Equivalent to BLO.;6809
BEQ;Branch if Equal (Z=1);TEMP ← MI  !IFF Z = 1 then PC' ← PC + TEMP!!Tests the state of the Z (zero) bit and causes a branch if it is set. When used after a subtract or compare operation, this Instruction will branch If the compared values, signed or unsigned, were exactly the same.;6809
BGE;Branch if Greater Than or Equal to Zero (Z=1 or N XOR V=0) (Signed);TEMP ← MI  !IFF [N ⊕ V] = 0 then PC' ← PC + TEMP!!Causes a branch if the N (negative) bit and the V (overflow) bit are either both set or both clear. That is, branch if the sign of a valid twos complement result is, or would be, positive. When used after a subtract or compare operation on twos complement values, this instruction will branch if the register was greater than or equal to the memory operand.;6809
BGT;Branch if Greater (N XOR V=0) (Signed);TEMP ← MI  !IFF Z ∩ [N ⊕ V] = 0 then PC' ← PC + TEMP!!Causes a branch if the N (negative) bit and V (overflow) bit are either both set or both clear and the Z (zero) bit is clear. In other words, branch if the sign of a valid twos complement result is, or would be, positive and not zero. When used after a subtract or compare operation on twos complement values, this instruction will branch if the register was greater than the memory operand.;6809
BHI;Branch if Higher (Z=0 AND C=0) (Unsigned);TEMP ← MI  !IFF [C ∪ Z] = 0 then PC' ← PC + TEMP!!Causes a branch if the previous operation caused neither a carry nor a zero result. When used after a subtract or compare operation on unsigned binary values, this instruction will branch if the register was higher than the memory operand.!!Generally not useful after INC/DEC, LD/TST, and TST/CLR/COM instructions.;6809
BHS;Branch if Higher or Same (C=0) (Unsigned);TEMP ← MI  !IFF C = 0 then PC' ← PC + TEMP!!Tests the state of the C (carry) bit and causes a branch if it is clear. When used after a subtract or compare on unsigned binary values, this instruction will branch if the register was higher than or the same as the memory operand.!!This is a duplicate assembly-language mnemonic for the single machine instruction BCC. Generally not useful after INC/DEC, LD/ST, and TST/CLR/COM instructions.;6809
BLE;Branch if Less than or Equal to Zero (Z=1 or N XOR V=0) (Signed);TEMP ← MI  !IFF Z ∪ [N ⊕ V] = 0 then PC' ← PC + TEMP!!Causes a branch if the exclusive OR of the N (negative) and V (overflow) bits is 1 or if the Z (zero) bit is set. That is, branch if the sign of a valid twos complement result is, or would be, negative. When used after a subtract or compare operation on twos complement values, this instruction will branch if the register was less than or equal to the memory operand.;6809
BLO;Branch if Lower (C=1) (Unsigned);TEMP ← MI  !IFF C = 1 then PC' ← PC + TEMP!!Tests the state of the (carry) bit and causes a branch if it is set. When used after a subtract or compare on unsigned binary values, this instruction will branch if the register was lower than the memory operand.!!This is a duplicate assembly-language mnemonic for the single machine instruction BCS. Generally not useful after INC/DEC.;6809
BLS;Branch if Lower or Same (Z=1 or C=1) (Unsigned);TEMP ← MI  !IFF [C ∪ Z] = 1 then PC' ← PC + TEMP!!Causes a branch if the previous operation caused either a carry or a zero result. When used after a subtract or compare operation on unsigned binary values, this instruction will branch if the register was lower than or the same as the memory operand.!!Generally not useful after INC/DEC, LD/ST, and TST/CLR/COM instructions.;6809
BLT;Branch if Less than Zero (N XOR V=1) (Signed);TEMP ← MI  !IFF [N ⊕ V] = 1 then PC' ← PC + TEMP!!Causes a branch if either, but not both, of the N (negative) or V (overflow) bits is set. That is, branch if the sign of a valid twos complement result is, or would be, negative. When used after a subtract or compare operation on twos complement binary values, this instruction will branch if the register was less than the memory operand.;6809
BMI;Branch if Minus (N=1);TEMP ← MI  !IFF N = 1 then PC' ← PC + TEMP!!Tests the state of the N (negative) bit and causes a branch if set. That is, branch if the sign of the twos compiement result is negative.!!When used after an operation on signed binary values, this instruction will branch if the result is minus. It is generally preferred to use the BLT instruction after signed operations.;6809
BNE;Branch Not Equal (Z=0);TEMP ← MI  !IFF Z = 0 then PC' ← PC + TEMP!!Tests the state of the Z (zero) bit and causes a branch if it is clear. When used after a subtract or compare operation on any binary values, this instruction will branch if the register is, or would be, not equal to the memory operand.;6809
BPL;Branch if Plus (N=0);TEMP ← MI  !IFF N = 0 then PC' ← PC + TEMP!!Tests the state of the N (negative) bit and causes a branch if it is clear. That is, branch if the sign of the twos complement result is positive.!!When used after an operation on signed binary values, this instruction will branch if the result (possibly invalid) is positive. It is generally preferred to use the BGE instruction after signed operations.;6809
BRA;Branch Always;TEMP ← MI  !PC' ← PC + TEMP!!Causes an unconditlonal branch.;6809
BRN;Branch Never (NOP);TEMP ← MI!!Does not cause a branch. This instruction is essentially a no operation, but has a bit pattern logically related to branch always.;6809
BSR;Branch to Subroutine;TEMP ← MI  !SP' ← SP-1, (SP) ← PCL  !SP' ← SP-1, (SP) ← PCH  !PC ← PC + TEMP!!The program counter is pushed onto the stack. The program counter is then loaded with the sum of the program counter and the offset.!!A return from subroutine (RTS) Instruction is used to reverse this process and must be the last instruction executed in a subroutine.;6809
BVC;Branch if valid twos complement result (V=0);TEMP ← MI  !IFF V = 0 then PC' ← PC + TEMP!!Tests the state of the V (overflow) bit and causes a branch if it is clear. That is, branch if the twos complement result was valid. When used after an operation on twos complement binary values, this instruction will branch if there was no overflow.;6809
BVS;Branch if invalid twos complement result (V=1);TEMP ← MI  !IFF V = 1 then PC' ← PC + TEMP!!Tests the state of the V (overflow) bit and causes a branch if it is set. That is, branch if the twos complement result was invalid. When used after an operation on twos complement binary values, this instruction will branch if there was an overflow.;6809
BAND;Logical AND Register Bit with Memory Bit into Register Bit;R.d' ← R.d ∩ DPM.s!!Logical AND bit s of the contents of direct addressed memory location DPM into bit d of the contents of register R.;6309
BEOR;Logical EOR Register Bit with Memory Bit into Register Bit;R.d' ← R.d ⊕ DPM.s!!Exclusive OR bit s of the contents of direct addressed memory location DPM into bit d of the contents of register R.;6309
BIAND;Logical AND Register Bit with Inverted Memory Bit into Register Bit;R.d' ← R.d ∩ not DPM.s!!Logically AND inverted bit s of the contents of direct addressed memory location DPM into bit d of the contents of register R.;6309
BIEOR;Logical EOR Register Bit with Inverted Memory Bit into Register Bit;R.d' ← R.d ⊕ not DPM.s!!Exclusive OR inverted bit s of the contents of direct addressed memory location DPM into bit d of the contents of register R.;6309
BIOR;Logical OR Register Bit with Inverted Memory Bit into Register Bit;R.d' ← R.d ∪ not DPM.s!!Locially OR inverted bit s of the contents of direct addressed memory location DPM into bit d of the contents of register R.;6309
BITA;Bit Test with A;TEMP ← R ∩ M!!Performs the logical AND of the contents of accumulator A and the contents of memory location M and modifies the condition codes accordingly. The contents of accumulator A and memory location M are not affected.;6809
BITB;Bit Test with B;TEMP ← R ∩ M!!Performs the logical AND of the contents of accumulator B and the contents of memory location M and modifies the condition codes accordingly. The contents of accumulator B and memory location M are not affected.;6809
BITD;Bit Test with D;TEMP ← R ∩ M!!Performs the logical AND of the contents of accumulator D and the contents of memory location M and modifies the condition codes accordingly. The contents of accumulator D and memory location M are not affected.;6309
BITMD;Bit Test with MD;CC.Z ← (MD.IL ∩ I.6 = 0) ∩ (MD./0 ∩ I.7 = 0)  !MD.IL' ← MD.IL ∩ not I.6  !MD./0 ← MD.0 ∩ not I.7!!Performs the logical AND of the two most-significant bits of register MD and the immediate value and modifies the Z condition code accordingly. The bits of the contents of the register MD are cleared if the corresponding bit in the immediate value is 1.;6309
BOR;Logical OR Register Bit with Memory Bit into Register Bit;R.d' ← R.d ∪ DPM.s!!Performs an logical OR operation between the bit d of the contents of register R and the bit s of the contents of direct addressed memory location DPM and the result is stored in bit d of the contents of register R.;6309
CLR;Clear Memory;TEMP ← M  !M ← $00!!The memory location is loaded with $00. Note that the EA is read during this operation.;6809
CLRA;Clear A;R ← $00!!Accumulator A is loaded with $00.;6809
CLRB;Clear B;R ← $00!!Accumulator B is loaded with $00.;6809
CLRD;Clear D;R ← $0000!!Accumulator D is loaded with $0000.;6309
CLRE;Clear E;R ← $00!!Accumulator E is loaded with $00.;6309
CLRF;Clear F;R ← $00!!Accumulator F is loaded with $00.;6309
CLRW;Clear W;R ← $0000!!Accumulator W is loaded with $0000.;6309
CMPA;Compare Memory from A;TEMP ← R - M!!Compares the contents of memory location to the contents of the specified register and sets the appropriate condition codes. Neither memory location M nor the specified register is modified. The carry flag represents a borrow and is set to the inverse of the resulting binary carry.;6809
CMPB;Compare Memory from B;TEMP ← R - M!!Compares the contents of memory location to the contents of the specified register and sets the appropriate condition codes. Neither memory location M nor the specified register is modified. The carry flag represents a borrow and is set to the inverse of the resulting binary carry.;6809
CMPE;Compare Memory from E;TEMP ← R - M!!Compares the contents of memory location to the contents of the specified register and sets the appropriate condition codes. Neither memory location M nor the specified register is modified. The carry flag represents a borrow and is set to the inverse of the resulting binary carry.;6309
CMPF;Compare Memory from F;TEMP ← R - M!!Compares the contents of memory location to the contents of the specified register and sets the appropriate condition codes. Neither memory location M nor the specified register is modified. The carry flag represents a borrow and is set to the inverse of the resulting binary carry.;6309
CMPD;Compare Memory from D;TEMP ← R - M:M+1!!Compares the contents of memory location to the contents of the specified register and sets the appropriate condition codes. Neither memory location M nor the specified register is modified. The carry flag represents a borrow and is set to the inverse of the resulting binary carry.;6809
CMPW;Compare Memory from W;TEMP ← R - M:M+1!!Compares the contents of memory location to the contents of the specified register and sets the appropriate condition codes. Neither memory location M nor the specified register is modified. The carry flag represents a borrow and is set to the inverse of the resulting binary carry.;6309
CMPX;Compare Memory from X;TEMP ← R - M:M+1!!Compares the contents of memory location to the contents of the specified register and sets the appropriate condition codes. Neither memory location M nor the specified register is modified. The carry flag represents a borrow and is set to the inverse of the resulting binary carry.;6809
CMPY;Compare Memory from Y;TEMP ← R - M:M+1!!Compares the contents of memory location to the contents of the specified register and sets the appropriate condition codes. Neither memory location M nor the specified register is modified. The carry flag represents a borrow and is set to the inverse of the resulting binary carry.;6809
CMPR;Compare Register from Register;TEMP ← R1 - R0!!Compares the contents of register R1 to the contents of the register R0 and sets the appropriate condition codes. Neither register is modified. The carry flag represents a borrow and is set to the inverse of the resulting binary carry.;6309
CMPS;Compare Memory from S;TEMP ← R - M:M+1!!Compares the contents of memory location to the contents of the specified register and sets the appropriate condition codes. Neither memory location M nor the specified register is modified. The carry flag represents a borrow and is set to the inverse of the resulting binary carry.;6809
CMPU;Compare Memory from U;TEMP ← R - M:M+1!!Compares the contents of memory location to the contents of the specified register and sets the appropriate condition codes. Neither memory location M nor the specified register is modified. The carry flag represents a borrow and is set to the inverse of the resulting binary carry.;6809
COM;Complement Memory;M' ← 0 + M̅!!Replaces the contents of memory location M or accumulator A or B with its logical complement. When operating on unsigned values, only BEQ and BNE branches can be expected to behave properly following a COM instruction. When operating on twos complement values, all signed branches are available.;6809
COMA;Complement A;R' ← 0 + R̅!!Replaces the contents of memory location M or accumulator A or B with its logical complement. When operating on unsigned values, only BEQ and BNE branches can be expected to behave properly following a COM instruction. When operating on twos complement values, all signed branches are available.;6809
COMB;Complement B;R' ← 0 + R̅!!Replaces the contents of memory location M or accumulator A or B with its logical complement. When operating on unsigned values, only BEQ and BNE branches can be expected to behave properly following a COM instruction. When operating on twos complement values, all signed branches are available.;6809
COMD;Complement D;R' ← 0 + R̅!!Replaces the contents of memory location M or accumulator A or B with its logical complement. When operating on unsigned values, only BEQ and BNE branches can be expected to behave properly following a COM instruction. When operating on twos complement values, all signed branches are available.;6309
COME;Complement E;R' ← 0 + R̅!!Replaces the contents of memory location M or accumulator A or B with its logical complement. When operating on unsigned values, only BEQ and BNE branches can be expected to behave properly following a COM instruction. When operating on twos complement values, all signed branches are available.;6309
COMF;Complement F;R' ← 0 + R̅!!Replaces the contents of memory location M or accumulator A or B with its logical complement. When operating on unsigned values, only BEQ and BNE branches can be expected to behave properly following a COM instruction. When operating on twos complement values, all signed branches are available.;6309
COMW;Complement W;R' ← 0 + R̅!!Replaces the contents of memory location M or accumulator A or B with its logical complement. When operating on unsigned values, only BEQ and BNE branches can be expected to behave properly following a COM instruction. When operating on twos complement values, all signed branches are available.;6309
CWAI;Clear CC bit's and Wait for Interrupt;CCR' ← CCR A MI (Possibly clear masks)  !Set E (entire state saved)  !SP' ← SP-1, (SP) ← PCL  !SP ←  SP-1, (SP) ← PCH  !SP' ← SP-1, (SP) ← USL  !SP ← SP-1, (SP) ← USH  !SP ← SP-1, (SP) ← IYL  !SP' ← SP-1, (SP) ← IYH  !SP' ← SP-1, (SP) ← IXL  !SP' ← SP-1, (SP) ← IXH  !SP' ← SP-1, (SP) ← DPR  !SP' ← SP-1, (SP) ← ACCB  !SP' ← SP-1, (SP) ← ACCA  !SP' ← SP-1, (SP) ← CCR!!This instruction ANDs an immediate byte with the condition code register which may clear the interrupt mask bits I and F, stacks the entire machine state on the hardware stack and then looks for an interrupt. When a non-masked interrupt occurs, no further machine state information need be saved before vectoring to the interrupt handling routine. This instruction replaced the MC6800 CLI WAI sequence, but does not place the buses in a high-impedance state. A F̅I̅R̅Q̅ (fast interrupt request) may enter its interrupt handler with its entire machine state saved. The RTI (return from interrupt) instruction will automatically return the entire machine state after testing the E (entire) bit of the recovered condition code register.!!The following immediate values will have the following results:!!FF = enable neither  !EF = enable F̅R̅Q̅  !BF = enable F̅I̅R̅Q̅  !AF = enable both;6809
DAA;Decimal Addition Adjust;ACCA' ← ACCA + CF(MSN):CF(LSN)  !where CF is a Correction Factor, as follows: the CF for each nibble (BCD) digit is determined separately, and is either 6 or 0.!!**Least Significant Nibble**!!| | |!| ---: | :---|!| CF(LSN) = 6 IFF |  1) C = 1 |!| or | 2) LSN>9 |!!**Most Significant Nibble**!!| | |!| ---: | :---|!| CF(MSN) = 6 IFF | 1) C = 1 |!| or | 2) MSN > 9 |!| or | 3) MSN > 8 *and* LSN > 9 |!!The sequence of a single-byte add instruction on accumulator A (either ADDA or ADCA) and a following decimal addition adjust instruction results in a BCD addition with an appropriate carry bit. Both values to be added must be in proper BCD form (each nibble such that: 0 < nibble < 9). Multiple-precision addition must add the carry generated by this decimal addition adjust into the next higher digit during the add operation (ADCA) immediately prior to the next decimal addition adjust.;6809
DEC;Decrement;M' ← M - 1!!Subtract one from the operand. The carry bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only BEQ and BNE branches can be expected to behave consistently. When operating on twos complement values, all signed branches are available.;6809
DECA;Decrement A;R' ← R - 1!!Subtract one from the operand. The carry bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only BEQ and BNE branches can be expected to behave consistently. When operating on twos complement values, all signed branches are available.;6809
DECB;Decrement B;R' ← R - 1!!Subtract one from the operand. The carry bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only BEQ and BNE branches can be expected to behave consistently. When operating on twos complement values, all signed branches are available.;6809
DECD;Decrement D;R' ← R - 1!!Subtract one from the operand. The carry bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only BEQ and BNE branches can be expected to behave consistently. When operating on twos complement values, all signed branches are available.;6309
DECE;Decrement E;R' ← R - 1!!Subtract one from the operand. The carry bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only BEQ and BNE branches can be expected to behave consistently. When operating on twos complement values, all signed branches are available.;6309
DECF;Decrement F;R' ← R - 1!!Subtract one from the operand. The carry bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only BEQ and BNE branches can be expected to behave consistently. When operating on twos complement values, all signed branches are available.;6309
DECW;Decrement W;R' ← R - 1!!Subtract one from the operand. The carry bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only BEQ and BNE branches can be expected to behave consistently. When operating on twos complement values, all signed branches are available.;6309
DIVD;Signed Divide D by Memory;B' ← D ÷ M  !A' ← D mod M!!Divide the signed 16-bit contents of accumulator D (dividend) by the 8-bit contents of memory location M, place the 8-bit quotient into accumulator B and the 8-bit remainder in accumulator A. The sign of the remainder is always the same as the sign of the dividend unless the remainder is zero. If the contents of memory location M is zero, a Division-By-Zero exception is triggered (set bit 7 of the contents of the register MD, push the state onto the hardware stack, and jump to the illegal instruction vector).;6309
DIVQ;Signed Divide Q by Memory;W' ← Q ÷ M:M+1  !D' ← Q mod M:M+1!!Divide the signed 32-bit contents of accumulator Q (dividend) by the 16-bit contents of memory location M (divisor), place the 16-bit quotient into accumulator W and the 16-bit remainder in accumulator D. The sign of the remainder is always the same as the sign of the dividend unless the remainder is zero. If the contents of memory location M is zero, a Division-By-Zero exception is triggered (set bit 7 of the contents of the register MD, push the state onto the hardware stack, and jump to the illegal instruction vector).;6309
EIM;Logical EOR of Value into Memory;M' ← M ⊕ I!!The immediate value is exclusive ORed into memory location M.;6309
EORA;Exclusive OR Memory into A;R' ← R ⊕ M!!The contents of memory location M is exclusive ORed into an 8-blt register.;6809
EORB;Exclusive OR Memory into B;R' ← R ⊕ M!!The contents of memory location M is exclusive ORed into an 8-blt register.;6809
EORD;Exclusive OR Memory into D;R' ← R ⊕ M:M+1!!The contents of memory location M:M+1 is exclusive ORed into the 16-blt register.;6309
EORR;Exclusive OR Register into Register;R1' ← R0 ⊕ R1!!The contents of register R0 is exclusive ORed into the register R1.;6309
EXG;Exchange Registers;R1 ↔ R2!!Exchanges data between two designated registers. Only like size registers may be exchanged. (8-bit with 8-bit or 16-bit with 16-bit.);6809
INC;Increment Memory;M' ← M + 1!!Adds to the operand. The carry bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only the BEQ and BNE branches can be expected to behave consistently. When operating on twos complement values, all signed branches are correctly available.;6809
INCA;Increment A;R' ← R + 1!!Adds to the operand. The carry bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only the BEQ and BNE branches can be expected to behave consistently. When operating on twos complement values, all signed branches are correctly available.;6809
INCB;Increment B;R' ← R + 1!!Adds to the operand. The carry bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only the BEQ and BNE branches can be expected to behave consistently. When operating on twos complement values, all signed branches are correctly available.;6809
INCD;Increment D;R' ← R + 1!!Adds to the operand. The carry bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only the BEQ and BNE branches can be expected to behave consistently. When operating on twos complement values, all signed branches are correctly available.;6309
INCE;Increment E;R' ← R + 1!!Adds to the operand. The carry bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only the BEQ and BNE branches can be expected to behave consistently. When operating on twos complement values, all signed branches are correctly available.;6309
INCF;Increment F;R' ← R + 1!!Adds to the operand. The carry bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only the BEQ and BNE branches can be expected to behave consistently. When operating on twos complement values, all signed branches are correctly available.;6309
INCW;Increment W;R' ← R + 1!!Adds to the operand. The carry bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only the BEQ and BNE branches can be expected to behave consistently. When operating on twos complement values, all signed branches are correctly available.;6309
JMP;Jump;PC' ← EA!!Program control is transferred to the effective address.;6809
JSR;Jump to Subroutine;SP' ← SP - 1, (SP) ← PCL  !SP' ← SP - 1, (SP) ← PCH  !PC ← EA!!Program control is transferred to the effective address after storing the return address on the hardware stack. A RTS instruction should be the last executed instruction of the subroutine.;6809
LBCC;Long Branch if Carry Clear (C=0) (Unsigned);TEMP ← MI  !IFF C = 0 then PC' ← PC + TEMP!!Tests the state of the C (carry) bit and causes a branch If it Is clear.!!Equivalent to LBHS.;6809
LBCS;Long Branch if Carry Set (C=1) (Unsigned);TEMP ← MI  !IFF C = 1 then PC' ← PC + TEMP!!Tests the state of the C (carry) bit and causes a branch If it is set.!!Equivalent to LBLO.;6809
LBEQ;Long Branch if Equal (Z=1);TEMP ← MI  !IFF Z = 1 then PC' ← PC + TEMP!!Tests the state of the Z (zero) bit and causes a branch if it is set. When used after a subtract or compare operation, this Instruction will branch If the compared values, signed or unsigned, were exactly the same.;6809
LBGE;Long Branch if Greater Than or Equal to Zero (Z=1 or N XOR V=0) (Signed);TEMP ← MI  !IFF [N ⊕ V] = 0 then PC' ← PC + TEMP!!Causes a branch if the N (negative) bit and the V (overflow) bit are either both set or both clear. That is, branch if the sign of a valid twos complement result is, or would be, positive. When used after a subtract or compare operation on twos complement values, this instruction will branch if the register was greater than or equal to the memory operand.;6809
LBGT;Long Branch if Greater (N XOR V=0) (Signed);TEMP ← MI  !IFF Z ∩ [N ⊕ V] = 0 then PC' ← PC + TEMP!!Causes a branch if the N (negative) bit and V (overflow) bit are either both set or both clear and the Z (zero) bit is clear. In other words, branch if the sign of a valid twos complement result is, or would be, positive and not zero. When used after a subtract or compare operation on twos complement values, this instruction will branch if the register was greater than the memory operand.;6809
LBHI;Long Branch if Higher (Z=0 AND C=0) (Unsigned);TEMP ← MI  !IFF [C ∪ Z] = 0 then PC' ← PC + TEMP!!Causes a branch if the previous operation caused neither a carry nor a zero result. When used after a subtract or compare operation on unsigned binary values, this instruction will branch if the register was higher than the memory operand.!!Generally not useful after INC/DEC, LD/TST, and TST/CLR/COM instructions.;6809
LBHS;Long Branch if Higher or Same (C=0) (Unsigned);TEMP ← MI  !IFF C = 0 then PC' ← PC + TEMP!!Tests the state of the C (carry) bit and causes a branch if it is clear. When used after a subtract or compare on unsigned binary values, this instruction will branch if the register was higher than or the same as the memory operand.!!This is a duplicate assembly-language mnemonic for the single machine instruction LBCC. Generally not useful after INC/DEC, LD/ST, and TST/CLR/COM instructions.;6809
LBLE;Long Branch if Less than or Equal to Zero (Z=1 or N XOR V=0) (Signed);TEMP ← MI  !IFF Z ∪ [N ⊕ V] = 0 then PC' ← PC + TEMP!!Causes a branch if the exclusive OR of the N (negative) and V (overflow) bits is 1 or if the Z (zero) bit is set. That is, branch if the sign of a valid twos complement result is, or would be, negative. When used after a subtract or compare operation on twos complement values, this instruction will branch if the register was less than or equal to the memory operand.;6809
LBLO;Long Branch if Lower (C=1) (Unsigned);TEMP ← MI  !IFF C = 1 then PC' ← PC + TEMP!!Tests the state of the (carry) bit and causes a branch if it is set. When used after a subtract or compare on unsigned binary values, this instruction will branch if the register was lower than the memory operand.!!This is a duplicate assembly-language mnemonic for the single machine instruction LBCS. Generally not useful after INC/DEC.;6809
LBLS;Long Branch if Lower or Same (Z=1 or C=1) (Unsigned);TEMP ← MI  !IFF [C ∪ Z] = 1 then PC' ← PC + TEMP!!Causes a branch if the previous operation caused either a carry or a zero result. When used after a subtract or compare operation on unsigned binary values, this instruction will branch if the register was lower than or the same as the memory operand.!!Generally not useful after INC/DEC, LD/ST, and TST/CLR/COM instructions.;6809
LBLT;Long Branch if Less than Zero (N XOR V=1) (Signed);TEMP ← MI  !IFF [N ⊕ V] = 1 then PC' ← PC + TEMP!!Causes a branch if either, but not both, of the N (negative) or V (overflow) bits is set. That is, branch if the sign of a valid twos complement result is, or would be, negative. When used after a subtract or compare operation on twos complement binary values, this instruction will branch if the register was less than the memory operand.;6809
LBMI;Long Branch if Minus (N=1);TEMP ← MI  !IFF N = 1 then PC' ← PC + TEMP!!Tests the state of the N (negative) bit and causes a branch if set. That is, branch if the sign of the twos compiement result is negative.!!When used after an operation on signed binary values, this instruction will branch if the result is minus. It is generally preferred to use the LBLT instruction after signed operations.;6809
LBNE;Long Branch Not Equal (Z=0);TEMP ← MI  !IFF Z = 0 then PC' ← PC + TEMP!!Tests the state of the Z (zero) bit and causes a branch if it is clear. When used after a subtract or compare operation on any binary values, this instruction will branch if the register is, or would be, not equal to the memory operand.;6809
LBPL;Long Branch if Plus (N=0);TEMP ← MI  !IFF N = 0 then PC' ← PC + TEMP!!Tests the state of the N (negative) bit and causes a branch if it is clear. That is, branch if the sign of the twos complement result is positive.!!When used after an operation on signed binary values, this instruction will branch if the result (possibly invalid) is positive. It is generally preferred to use the LBGE instruction after signed operations.;6809
LBRA;Long Branch Always;TEMP ← MI  !!PC' ← PC + TEMP!!Causes an unconditlonai branch.;6809
LBRN;Long Branch Never (NOP);TEMP ← MI!!Does not cause a branch. This instruction is essentially a no operation, but has a bit pattern logically related to branch always.;6809
LBSR;Long Branch to Subroutine;TEMP ← MI  !SP' ← SP-1, (SP) ← PCL  !SP' ← SP-1, (SP) ← PCH  !PC ← PC + TEMP!!The program counter is pushed onto the stack. The program counter is then loaded with the sum of the program counter and the offset.!!A return from subroutine (RTS) Instruction is used to reverse this process and must be the last instruction executed in a subroutine.;6809
LBVC;Long Branch if valid twos complement result (V=0);TEMP ← MI  !IFF V = 0 then PC' ← PC + TEMP!!Tests the state of the V (overflow) bit and causes a branch if it is clear. That is, branch if the twos complement result was valid. When used after an operation on twos complement binary values, this instruction will branch if there was no overflow.;6809
LBVS;Long Branch if invalid twos complement result (V=1);TEMP ← MI  !IFF V = 1 then PC' ← PC + TEMP!!Tests the state of the V (overflow) bit and causes a branch if it is set. That is, branch if the twos complement result was invalid. When used after an operation on twos complement binary values, this instruction will branch if there was an overflow.;6809
LDA;Load A from Memory;R' ← M!!Loads the contents of memory location M into the designated register.;6809
LDB;Load B from Memory;R' ← M!!Loads the contents of memory location M into the designated register.;6809
LDD;Load D from Memory;R' ← M:M+1!!Load the contents of the memory location M:M+1 into the designated 16-bit register.;6309
LDE;Load E from Memory;R' ← M!!Loads the contents of memory location M into the designated register.;6309
LDF;Load F from Memory;R' ← M!!Loads the contents of memory location M into the designated register.;6309
LDW;Load W from Memory;R' ← M:M+1!!Load the contents of the memory location M:M+1 into the designated 16-bit register.;6309
LDX;Load X from Memory;R' ← M:M+1!!Load the contents of the memory location M:M+1 into the designated 16-bit register.;6809
LDY;Load Y from Memory;R' ← M:M+1!!Load the contents of the memory location M:M+1 into the designated 16-bit register.;6809
LDS;Load S from Memory;R' ← M:M+1!!Load the contents of the memory location M:M+1 into the designated 16-bit register.;6809
LDU;Load U from Memory;R' ← M:M+1!!Load the contents of the memory location M:M+1 into the designated 16-bit register.;6809
LDBT;Load Register Bit from Memory;R.d' ← DPM.s!!Load bit s of the contents of direct address memory location DPM into bit d of the register R. No condition codes are affected.;6309
LDMD;Load Value into MD;MD.NM' ← I.0  !MD.FM ← I.1!!Loads the native mode and FIRQ mode bits (two least-significant bits) of the immediate value into the register MD. No condition codes are affected.;6309
LDQ;Load Q from Memory;Q! ← M:M+3!!Load the contents of the memory location M:M+3 into the designated 32-bit register.;6309
LEAX;Load Effective Address into X;R' ← EA!!Calculates the effective address from the indexed addressing and places the address in an indexable register.!!LEAX affects the Z (zero) bit to allow use of these registers as counters and for MC6800 INX/DEX compatibility.!!Due to the order in which effective addresses are calculated internally, the LEAX ,X++ and LEAX ,X+ do not add 2 and 1 (respectively) to the X register, but instead leave the X register unchanged. This also applies to the Y, U, and S registers. For the expected results, use the faster instruction LEAX 2,X and LEAX 1,X.!!Some examples of LEA instruction uses are given in the following table.!!| Instruction | Operation | Comment |!| :--- | :--- | :--- |!| LEAX 10,X | X + 10 → X | Adds 5-bit constant 10 to X |!| LEAX 500,X | X + 500 → X | Adds 16-bit constant 500 to X |!| LEAY A,Y | Y + A → Y | Adds 8-bit accumulator to Y |!| LEAY D,Y | Y + D → Y | Adds 16-bit D accumulator to Y |!| LEAU -10,U | U - 10 → U | Subtracts 10 from U |!| LEAS -10,S | S - 10 → S | Used to reserve area on stack |!| LEAS 10,S | S + 10 → S | Used to 'clean up' stack |!| LEAX 5,S | S + 5 → X | Transfers as well as adds |;6809
LEAY;Load Effective Address into Y;R' ← EA!!Calculates the effective address from the indexed addressing and places the address in an indexable register.!!LEAY affects the Z (zero) bit to allow use of these registers as counters and for MC6800 INX/DEX compatibility.!!Due to the order in which effective addresses are calculated internally, the LEAX ,X++ and LEAX ,X+ do not add 2 and 1 (respectively) to the X register, but instead leave the X register unchanged. This also applies to the Y, U, and S registers. For the expected results, use the faster instruction LEAX 2,X and LEAX 1,X.!!Some examples of LEA instruction uses are given in the following table.!!| Instruction | Operation | Comment |!| :--- | :--- | :--- |!| LEAX 10,X | X + 10 → X | Adds 5-bit constant 10 to X |!| LEAX 500,X | X + 500 → X | Adds 16-bit constant 500 to X |!| LEAY A,Y | Y + A → Y | Adds 8-bit accumulator to Y |!| LEAY D,Y | Y + D → Y | Adds 16-bit D accumulator to Y |!| LEAU -10,U | U - 10 → U | Subtracts 10 from U |!| LEAS -10,S | S - 10 → S | Used to reserve area on stack |!| LEAS 10,S | S + 10 → S | Used to 'clean up' stack |!| LEAX 5,S | S + 5 → X | Transfers as well as adds |;6809
LEAS;Load Effective Address into S;R' ← EA!!Calculates the effective address from the indexed addressing and places the address in an indexable register.!!LEAS does not affect the Z bit to allow cleaning up the stack while returning the Z bit as a parameter to a calling routine, and also for MC6800 INS/DES compatibility.!!Due to the order in which effective addresses are calculated internally, the LEAX ,X++ and LEAX ,X+ do not add 2 and 1 (respectively) to the X register, but instead leave the X register unchanged. This also applies to the Y, U, and S registers. For the expected results, use the faster instruction LEAX 2,X and LEAX 1,X.!!Some examples of LEA instruction uses are given in the following table.!!| Instruction | Operation | Comment |!| :--- | :--- | :--- |!| LEAX 10,X | X + 10 → X | Adds 5-bit constant 10 to X |!| LEAX 500,X | X + 500 → X | Adds 16-bit constant 500 to X |!| LEAY A,Y | Y + A → Y | Adds 8-bit accumulator to Y |!| LEAY D,Y | Y + D → Y | Adds 16-bit D accumulator to Y |!| LEAU -10,U | U - 10 → U | Subtracts 10 from U |!| LEAS -10,S | S - 10 → S | Used to reserve area on stack |!| LEAS 10,S | S + 10 → S | Used to 'clean up' stack |!| LEAX 5,S | S + 5 → X | Transfers as well as adds |;6809
LEAU;Load Effective Address into U;R' ← EA!!Calculates the effective address from the indexed addressing and places the address in an indexable register.!!LEAU does not affect the Z bit to allow cleaning up the stack while returning the Z bit as a parameter to a calling routine, and also for MC6800 INS/DES compatibility.!!Due to the order in which effective addresses are calculated internally, the LEAX ,X++ and LEAX ,X+ do not add 2 and 1 (respectively) to the X register, but instead leave the X register unchanged. This also applies to the Y, U, and S registers. For the expected results, use the faster instruction LEAX 2,X and LEAX 1,X.!!Some examples of LEA instruction uses are given in the following table.!!| Instruction | Operation | Comment |!| :--- | :--- | :--- |!| LEAX 10,X | X + 10 → X | Adds 5-bit constant 10 to X |!| LEAX 500,X | X + 500 → X | Adds 16-bit constant 500 to X |!| LEAY A,Y | Y + A → Y | Adds 8-bit accumulator to Y |!| LEAY D,Y | Y + D → Y | Adds 16-bit D accumulator to Y |!| LEAU -10,U | U - 10 → U | Subtracts 10 from U |!| LEAS -10,S | S - 10 → S | Used to reserve area on stack |!| LEAS 10,S | S + 10 → S | Used to 'clean up' stack |!| LEAX 5,S | S + 5 → X | Transfers as well as adds |;6809
LSL;Logical Memory Shift Left;C ←□□□□□□□□← 0!!Shifts all bits of memory location M one place to the left. Bit zero is loaded with a zero. Bit seven of memory location M is shifted into the (carry) bit.!!This is a duplicate assembly-language mnemonic for the single machine instruction ASL.;6809
LSLA;Logical A Shift Left;C ←□□□□□□□□← 0!!Shifts all bits of accumulator A one place to the left. Bit zero is loaded with a zero. Bit seven of accumulator A is shifted into the (carry) bit.!!This is a duplicate assembly-language mnemonic for the single machine instruction ASL.;6809
LSLB;Logical B Shift Left;C ←□□□□□□□□← 0!!Shifts all bits of accumulator B one place to the left. Bit zero is loaded with a zero. Bit seven of accumulator B is shifted into the (carry) bit.!!This is a duplicate assembly-language mnemonic for the single machine instruction ASL.;6809
LSLD;Logical D Shift Left;C ←□□□□□□□□□□□□□□□□← 0!!Shifts all bits of accumulator D one place to the left. Bit zero is loaded with a zero. Bit fifteen of accumulator D is shifted into the (carry) bit.!!This is a duplicate assembly-language mnemonic for the single machine instruction ASL.;6309
LSR;Logical Memory Shift Right;0 →□□□□□□□□→ C!!Performs a logical shift right on the operand. Shifts a zero into bit seven and bit zero into the C (carry) bit.;6809
LSRA;Logical A Shift Right;0 →□□□□□□□□→ C!!Performs a logical shift right on the operand. Shifts a zero into bit seven and bit zero into the C (carry) bit.;6809
LSRB;Logical B Shift Right;0 →□□□□□□□□→ C!!Performs a logical shift right on the operand. Shifts a zero into bit seven and bit zero into the C (carry) bit.;6809
LSRD;Logical D Shift Right;0 →□□□□□□□□□□□□□□□□→ C!!Performs a logical shift right on the operand. Shifts a zero into bit fifteen and bit zero into the C (carry) bit.;6309
LSRW;Logical W Shift Right;0 →□□□□□□□□□□□□□□□□→ C!!Performs a logical shift right on the operand. Shifts a zero into bit fifteen and bit zero into the C (carry) bit.;6309
MUL;Unsigned Multiply into D;A':B' ← A × B!!Multiply the unsigned contents accumulators A and B, place the result in both accumulators (the contents of accumulator A contains the most-significant byte of the result). Unsigned multiply allows multiple-precision operations.!!The C (carry) bit allows rounding the most-significant byte through the sequence: MUL, ADCA #0.;6809
MULD;Signed Multiply into Q;Q' ← D × I|M:M+1!!Multiply the signed contents of accumulators D and the contents of a 16-bit immediate value or the contents of memory location M, place the result in accumulator Q.;6309
NEG;Negate Memory;M' ← 0 - M!!Replaces the operand with its twos complement. The (carry) bit represents a borrow and is set to the inverse of the resulting binary carry. Note that $0080 is replaced by itself and only in this case is the V (overflow) bit set. The value $0000 is also replaced by itself, and only in this case is the C (carry) bit cleared.;6809
NEGA;Negate A;R' ← 0 - R!!Replaces the operand with its twos complement. The (carry) bit represents a borrow and is set to the inverse of the resulting binary carry. Note that $0080 is replaced by itself and only in this case is the V (overflow) bit set. The value $0000 is also replaced by itself, and only in this case is the C (carry) bit cleared.;6809
NEGB;Negate B;R' ← 0 - R!!Replaces the operand with its twos complement. The (carry) bit represents a borrow and is set to the inverse of the resulting binary carry. Note that $0080 is replaced by itself and only in this case is the V (overflow) bit set. The value $0000 is also replaced by itself, and only in this case is the C (carry) bit cleared.;6809
NEGD;Negate D;R' ← 0 - R!!Replaces the operand with its twos complement. The (carry) bit represents a borrow and is set to the inverse of the resulting binary carry. Note that $8000 is replaced by itself and only in this case is the V (overflow) bit set. The value $0000 is also replaced by itself, and only in this case is the C (carry) bit cleared.;6809
NOP;No Operation;This instruction causes only the program counter to be incremented. No other registers or memory locations are affected.;6809
OIM;Logical OR Value into Memory;M! ← M ∪ I!!Performs an inclusive OR operation between the contents of memory location M and the immediate value I and the result is stored in the memory location M.;6309
ORA;Inclusive OR Memory into A;R' ← R ∪ M!!Performs an inclusive OR operation between the contents of accumulator A and the contents of memory location M and the result is stored in accumulator A.;6809
ORB;Inclusive OR Memory into B;R' ← R ∪ M!!Performs an inclusive OR operation between the contents of accumulator B and the contents of memory location M and the result is stored in accumulator B.;6809
ORCC;Inclusive OR Memory into CC;R'— R ∪ MI!!Performs an inclusive OR operation between the contents of the condition code registers and the immediate value, and the result is piaced in the condition code register. This instruction may be used to set interrupt masks (disable interrupts) or any other bit(s).;6809
ORD;Inclusive OR Memory into D;R' ← R ∪ M:M+1!!Performs an inclusive OR operation between the contents of accumulator B and the contents of memory location M:M+1 and the result is stored in accumulator D.;6309
ORR;Inclusive OR Register into Register;R1' ← R1 ∪ R0!!Performs an inclusive OR operation between the contents of register R0 and the contents of register R1 and the result is stored in register R1.;6309
PSHS;Push Registers onto Hardware Stack;**Push Order**  !PC ⇢ U ⇢ Y ⇢ X ⇢ DP ⇢ B ⇢ A ⇢ CC!!All, some, or none of the processor registers are pushed onto the hardware stack (with the exception of the hardware stack pointer itself).!!A single register may be placed on the stack with the condition codes set by doing an autodecrement store onto the stack (example: STX ,--S).;6809
PSHSW;Push W onto Hardware Stack;S' ← S - 2  !S:S+1' ← W!!Autodecrements the contents of the hardware stack register and pushs the value of the register W (E and F) onto the hardware stack. Condition codes are not affected.;6309
PSHU;Push Registers onto User Stack;**Push Order**  !PC ⇢ S ⇢ Y ⇢ X ⇢ DP ⇢ B ⇢ A ⇢ CC!!All, some, or none of the processor registers are pushed onto the user stack (with the exception of the user stack pointer itself).!!A single register may be placed on the stack with the condition codes set by doing an autodecrement store onto the stack (example: STX ,--U).;6809
PSHUW;Push W onto User Stack;U' ← U - 2  !U:U+1' ← W!!Autodecrements the contents of the user stack register and pushs the value of the register W (E and F) onto the user stack. Condition codes are not affected.;6309
PULS;Pull Registers from Hardware Stack;**Pull Order**  !PC ⇠ U ⇠ Y ⇠ X ⇠ DP ⇠ B ⇠ A ⇠ CC!!All, some, or none of the processor registers are pulled from the hardware stack (with the exception of the hardware stack pointer itself).!!A single register may be pulled from the stack with condition codes set by doing an autoincrement load from the stack (example: LDX ,S++).;6809
PULSW;Pull W from Hardware Stack;W' ← S:S+1  !S' ← S + 2!!Pulls the value for register W (E and F) from the hardware stack and autoincrements the contents of the hardware stack register. Condition codes are not affected.;6309
PULU;Pull Registers from User Stack;**Pull Order**  !PC ⇠ S ⇠ Y ⇠ X ⇠ DP ⇠ B ⇠ A ⇠ CC!!All, some, or none of the processor registers are pulled from the user stack (with the exception of the user stack pointer itself).!!A single register may be pulled from the stack with condition codes set by doing an autoincrement load from the stack (example: LDX ,U++).;6809
PULUW;Pull W from User Stack;W' ← U:U+1  !U' ← U + 2!!Pulls the value for register W (E and F) from the user stack and autoincrements the contents of the user stack register. Condition codes are not affected.;6309
ROL;Rotate Memory Left;```html   !┌──────────────┐  !└─ C ←□□□□□□□□←┘  !```!!Rotates all bits of the operand one place left through the bit. This is a 9-bit rotation.;6809
ROLA;Rotate A Left;```html   !┌──────────────┐  !└─ C ←□□□□□□□□←┘  !```!!Rotates all bits of the operand one place left through the bit. This is a 9-bit rotation.;6809
ROLB;Rotate B Left;```html   !┌──────────────┐  !└─ C ←□□□□□□□□←┘  !```!!Rotates all bits of the operand one place left through the bit. This is a 9-bit rotation.;6809
ROLD;Rotate D Left;```html   !┌──────────────────────┐  !└─ C ←□□□□□□□□□□□□□□□□←┘  !```!!Rotates all bits of the operand one place left through the bit. This is a 17-bit rotation.;6309
ROLW;Rotate W Left;```html   !┌──────────────────────┐  !└─ C ←□□□□□□□□□□□□□□□□←┘  !```!!Rotates all bits of the operand one place left through the bit. This is a 17-bit rotation.;6309
ROR;Rotate Memory Right;```html   !┌──────────────┐  !└→ C →□□□□□□□□─┘  !```!!Rotates all bits of the operand one place right through the C (carry) bit. This is a 9-bit rotation.;6809
RORA;Rotate A Right;```html   !┌──────────────┐  !└→ C →□□□□□□□□─┘  !```!!Rotates all bits of the operand one place right through the C (carry) bit. This is a 9-bit rotation.;6809
RORB;Rotate B Right;```html   !┌──────────────┐  !└→ C →□□□□□□□□─┘  !```!!Rotates all bits of the operand one place right through the C (carry) bit. This is a 9-bit rotation.;6809
RORD;Rotate D Right;```html   !┌──────────────────────┐  !└→ C →□□□□□□□□□□□□□□□□─┘  !```!!Rotates all bits of the operand one place right through the C (carry) bit. This is a 17-bit rotation.;6309
RORW;Rotate W Right;```html   !┌──────────────────────┐  !└→ C →□□□□□□□□□□□□□□□□─┘  !```!!Rotates all bits of the operand one place right through the C (carry) bit. This is a 17-bit rotation.;6309
RTI;Return from Interrupt;CCR' ← (SP), SP' ← SP + 1, then!!| | |  !| :--- | :--- |  !IFF COR bit E is set, then: | ACCA' ← (SP), SP' ← SP + 1  !| | ACCB' ← (SP), SP' ← SP + 1  !| | DPR' ← (SP), SP' ← SP + 1  !| | IXH' ← (SP), SP' ← SP + 1  !| | IXL' ← (SP), SP' ← SP + 1  !| | IYH' ← (SP), SP' ← SP + 1  !| | IYL' ← (SP), SP' ← SP + 1  !| | USH' ← (SP), SP' ← SP + 1  !| | USL' ← (SP), SP' ← SP + 1  !| | PCH' ← (SP), SP' ← SP + 1  !| | PCL' ← (SP), SP' ← SP + 1  !| | |  !IFF CCR bit E is clear, then: | PCH' ← (SP), SP' ← SP + 1  !| | PCL' ← (SP), SP' ← SP + 1 |!!The saved machine state is recovered from the hardware stack and control is returned to the interrupted program. If the recovered E (entire) bit is clear, it indicates that only a subset of the machine state was saved (return address and condition codes) and only that subset is recovered.;6809
RTS;Return from Subroutine;PCH ← (SP), SP' ← SP + 1  !PCL' ← (SP), SP' ← SP + 1!!Program control is returned from the subroutine to the calling program. The return address is pulled from the stack.;6809
SBCA;Subtract Memory from A with Borrow;R' ← R - M - C!!Subtracts the contents of memory location M and the borrow (in the C (carry) bit) from the contents of the designated 8-bit register, and places the result in that register. The C bit represents a borrow and is set to the inverse of the resulting binary carry.;6809
SBCB;Subtract Memory from B with Borrow;R' ← R - M - C!!Subtracts the contents of memory location M and the borrow (in the C (carry) bit) from the contents of the designated 8-bit register, and places the result in that register. The C bit represents a borrow and is set to the inverse of the resulting binary carry.;6809
SBCD;Subtract Memory from D with Borrow;R' ← R - M:M+1 - C!!Subtracts the contents of memory location M:M+1 and the borrow (in the C (carry) bit) from the contents of the designated 16-bit register, and places the result in that register. The C bit represents a borrow and is set to the inverse of the resulting binary carry.;6309
SBCR;Subtract Register from Register with Borrow;R1' ← R1 - R0 - C!!Subtracts the contents of register R0 and the borrow (in the C (carry) bit) from the contents of the register R1, and places the result in the register R1. The C bit represents a borrow and is set to the inverse of the resulting binary carry.;6309
SEX;Sign Extend B into D;| | |  !| :--- | :--- |  !| If bit seven of ACCB is set | then ACCA' ← $FF |  !| | else ACCA' ← $00 |!!This instruction transforms a twos complement 8-bit value in accumulator B into a twos complement 16-bit value in the D accumulator.;6809
SEXW;Sign Extend W into Q;| | |  !| :--- | :--- |  !| If bit fifteen of ACCW is set | then ACCD' ← $FFFF |  !| | else ACCD' ← $0000 |!!This instruction transforms a twos complement 16-bit value in accumulator WAI into a twos complement 32-bit value in the Q accumulator.;6309
STA;Store A into Memory;M' ← R!!Writes the contents of an 8-bit register into a memory location.;6809
STB;Store B into Memory;M' ← R!!Writes the contents of an 8-bit register into a memory location.;6809
STE;Store E into Memory;M' ← R!!Writes the contents of an 8-bit register into a memory location.;6309
STF;Store F into Memory;M' ← R!!Writes the contents of an 8-bit register into a memory location.;6309
STD;Store D into Memory;M':M'+1 ← R!!Writes the contents of a 16-bit register into two consecutive memory locations;6809
STW;Store W into Memory;M':M'+1 ← R!!Writes the contents of a 16-bit register into two consecutive memory locations;6309
STX;Store X into Memory;M':M'+1 ← R!!Writes the contents of a 16-bit register into two consecutive memory locations;6809
STY;Store Y into Memory;M':M'+1 ← R!!Writes the contents of a 16-bit register into two consecutive memory locations;6809
STS;Store S into Memory;M':M'+1 ← R!!Writes the contents of a 16-bit register into two consecutive memory locations;6809
STU;Store U into Memory;M':M'+1 ← R!!Writes the contents of a 16-bit register into two consecutive memory locations;6809
STBT;Store Register Bit into Memory;DPM.d' ← R.s!!Write bit s of the contents of register R into bit d in direct addressed memory location DPM. Condition Codes are not affected.;6309
STQ;Store Q into Memory;M':M'+3 ← R!!Writes the contents of an 32-bit register into four consecutive memory locations;6309
SUBA;Subtract Memory from A;R' ← R - M!!Subtracts the value in memory location M from the contents of a designated 8-bit register. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry.;6809
SUBB;Subtract Memory from B;R' ← R - M!!Subtracts the value in memory location M from the contents of a designated 8-bit register. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry.;6809
SUBD;Subtract Memory from D;R' ← R - M:M+1!!Subtracts the value in memory location M:M+1 from the contents of a designated 16-bit register. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry.;6809
SUBR;Subtract Register from Register;R1' ← R1 - R0!!Subtracts the contents of register R0 from the contents of register R1. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry.;6309
SWI;Software Interrupt;Set E (entire state will be saved)  !SP' ← SP - 1, (SP) ← PCL  !SP' ← SP - 1, (SP) ← PCH  !SP' ← SP - 1, (SP) ← USL  !SP' ← SP - 1, (SP) ← USH  !SP' ← SP - 1, (SP) ← IYL  !SP' ← SP - 1, (SP) ← IYH  !SP' ← SP - 1, (SP) ← IXL  !SP' ← SP - 1, (SP) ← IXH  !SP' ← SP - 1, (SP) ← DPR  !SP' ← SP - 1, (SP) ← ACCB  !SP' ← SP - 1, (SP) ← ACCA  !SP' ← SP - 1, (SP) ← CCR   !Set I, F (mask interrupts)  !PC' ← ($FFFA):($FFFB)!!All of the processor registers are pushed onto the hardware stack (with the exception of the hardware stack pointer itself), and control is transferred through the software Interrupt vector. Both the normal and fast interrupts are masked (disabled).;6809
SWI2;Software Interrupt 2;Set E (entire state will be saved)  !SP' ← SP - 1, (SP) ← PCL  !SP' ← SP - 1, (SP) ← PCH  !SP' ← SP - 1, (SP) ← USL  !SP' ← SP - 1, (SP) ← USH  !SP' ← SP - 1, (SP) ← IYL  !SP' ← SP - 1, (SP) ← IYH  !SP' ← SP - 1, (SP) ← IXL  !SP' ← SP - 1, (SP) ← IXH  !SP' ← SP - 1, (SP) ← DPR  !SP' ← SP - 1, (SP) ← ACCB  !SP' ← SP - 1, (SP) ← ACCA  !SP' ← SP - 1, (SP) ← CCR   !Set I, F (mask interrupts)  !PC' ← ($FFF4):($FFF5)!!All of the processor registers are pushed onto the hardware stack (with the exception of the hardware stack pointer itself), and control is transferred through the software interrupt 2 vector. This interrupt is available to the end user and must not be used in packaged soft- ware. This interrupt does not mask (disable) the norma! and fast in- terrupts.;6809
SWI3;Software Interrupt 3;Set E (entire state will be saved)  !SP' ← SP - 1, (SP) ← PCL  !SP' ← SP - 1, (SP) ← PCH  !SP' ← SP - 1, (SP) ← USL  !SP' ← SP - 1, (SP) ← USH  !SP' ← SP - 1, (SP) ← IYL  !SP' ← SP - 1, (SP) ← IYH  !SP' ← SP - 1, (SP) ← IXL  !SP' ← SP - 1, (SP) ← IXH  !SP' ← SP - 1, (SP) ← DPR  !SP' ← SP - 1, (SP) ← ACCB  !SP' ← SP - 1, (SP) ← ACCA  !SP' ← SP - 1, (SP) ← CCR   !Set I, F (mask interrupts)  !PC' ← ($FFF2):($FFF3)!!All of the processor registers are pushed onto the hardware stack (with the exception of the hardware stack pointer itself), and control is transferred through the software interrupt 3 vector. This interrupt does not mask (disable) the normal and fast interrupts.;6809
SYNC;Synchronize to External Event;When a SYNC instruction is excuted, tlie processor enters a synchronizing state, stops processing instructions, and waits for an interrupt. When an interrupt occurs, the synchronizing state is cleared and processing continues. If the interrupt is enabled, and it lasts three cycles or more, the processor will perform the interrupt routine. If the interrupt is masked or is shorter than three cycles, the processor simply continues to the next instruction. While in the synchronizing state, the address and data buses are in the high-impedance state.!!This instruction provides software synchronization with a hardware process. Consider the following example for high-speed acquisition of data:!!```!FAST   SYNC             WAIT FOR DATA!       Interrupt!!       LDA        DISC  DATA FROM DISC AND CLEAR INTERRUPT!       STA        ,X+   PUT IN BUFFER!       DECB             COUNT IT, DONE?!       BNE        FAST  GO AGAIN IF NOT.!```!!The synchronizing state is cleared by any interrupt. Of course, enabled interrupts at this point may destroy the data transfer and, as such, should represent only emergency conditions.!!The same connection used for interrupt-driven I/O service may also be used for high-speed data transfers by setting the interrupt mask and using the SYNC instruction as the above example demonstrates.;6809
TFM;Transfer Memory;M':M'+W ← M:M+W!!Transfer the number of bytes specified in W from the source memory locations to the destination memory locations;6309
TFR;Transfer Register to Register;R1 → R2'!!Transfers data between two designated registers. Only like size registers may be transferred. (8-bit to 8-bit, or 16-bit to 16-bit.);6809
TIM;Bit Test Value with Memory;TEMP ← M ∩ I!!Performs the logical AND of the contents of the contents of memory location M and the 8-bit intermediate value and modifies the condition codes accordingly. The content of memory location M is not affected.;6309
TST;Test Memory;TEMP ← M - 0!!Set the N (negative) and Z (zero) bits according to the contents of memory location M, and clear the V (overflow) bit. The TST instruction provides only minimum information when testing unsigned values, since no unsigned value is less than zero, BLO and BLS have no utility. While BHI could be used after TST, it provides exactly the same control as BNE, which is preferred. The signed branches are available.;6809
TSTA;Test A;TEMP ← R - 0!!Set the N (negative) and Z (zero) bits according to the contents of accumulator A and clear the V (overflow) bit. The TST instruction provides only minimum information when testing unsigned values, since no unsigned value is less than zero, BLO and BLS have no utility. While BHI could be used after TST, it provides exactly the same control as BNE, which is preferred. The signed branches are available.;6809
TSTB;Test B;TEMP ← R - 0!!Set the N (negative) and Z (zero) bits according to the contents of accumulator B and clear the V (overflow) bit. The TST instruction provides only minimum information when testing unsigned values, since no unsigned value is less than zero, BLO and BLS have no utility. While BHI could be used after TST, it provides exactly the same control as BNE, which is preferred. The signed branches are available.;6809
