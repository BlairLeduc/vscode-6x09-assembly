ABX;6809;H=• N=• Z=• V=• C=•;Add B into X (Unsigned);IX' ← IX + ACCB!!Add the 8-bit unsigned value in accumulator B into index register X.
ADCA;6809;H=↕ N=↕ Z=↕ V=↕ C=↕;Add Memory with Carry into A;R' ← R + M + C!!Adds the contents of the C (carry) bit and the memory byte into an 8-blt accumulator.
ADCB;6809;H=↕ N=↕ Z=↕ V=↕ C=↕;Add Memory with Carry into B;R' ← R + M + C!!Adds the contents of the C (carry) bit and the memory byte into an 8-blt accumulator.
ADCD;6309;H=• N=↕ Z=↕ V=↕ C=↕;Add Memory with Carry into D;R' ← R + M:M+1 + C!!Adds the contents of the C (carry) bit and the 16-bit memory value into the 16-blt accumulator.
ADCR;6309;H=• N=↕ Z=↕ V=↕ C=↕;Add Register with Carry into Register;R1' ← R1 + R0 + C!!Adds the contents of the C (carry) bit and the contents of register R0 into the register R1.
ADDA;6809;H=↕ N=↕ Z=↕ V=↕ C=↕;Add Memory into A;R' ← R + M!!Adds the memory byte into an 8-bit accumulator.
ADDB;6809;H=↕ N=↕ Z=↕ V=↕ C=↕;Add Memory into B;R' ← R + M!!Adds the memory byte into an 8-bit accumulator.
ADDD;6809;H=• N=↕ Z=↕ V=↕ C=↕;Add Memory into D;R' ← R + M:M+1!!Adds the 16-bit memory value into the 16-bit accumulator.
ADDE;6309;H=↕ N=↕ Z=↕ V=↕ C=↕;Add Memory into E;R' ← R + M!!Adds the memory byte into an 8-bit accumulator.
ADDF;6309;H=↕ N=↕ Z=↕ V=↕ C=↕;Add Memory into F;R' ← R + M!!Adds the memory byte into an 8-bit accumulator.
ADDR;6309;H=• N=↕ Z=↕ V=↕ C=↕;Add Register into Register;R1' ← R1 + R0!!Adds the contents of register R1 and the contents of register R0 into a register R1.
ADDW;6309;H=• N=↕ Z=↕ V=↕ C=↕;Add Memory into W;R' ← R + M:M+1!!Adds the 16-bit memory value into the 16-bit accumulator.
AIM;6309;H=• N=↕ Z=↕ V=0 C=•;Logical AND of Value with Memory;M' ← M ∩ I!!Performs the logical AND operation between the contents of memory location M and the immediate value and the result is stored in memory location M.
ANDA;6809;H=• N=↕ Z=↕ V=0 C=•;Logical AND Memory into A;R' ← R ∩ M!!Performs the logical AND operation between the contents of an accumulator and the contents of memory location M and the result is stored in the accumulator.
ANDB;6809;H=• N=↕ Z=↕ V=0 C=•;Logical AND Memory into B;R' ← R ∩ M!!Performs the logical AND operation between the contents of an accumulator and the contents of memory location M and the result is stored in the accumulator.
ANDD;6309;H=• N=↕ Z=↕ V=0 C=•;Logical AND Memory into D;R' ← R ∩ M:M+1!!Performs the logical AND operation between the contents of an accumulator and the contents of memory location M and the result is stored in the accumulator.
ANDR;6309;H=• N=↕ Z=↕ V=0 C=•;Logical AND Memory into R;R1' ← R1 ∩ R0!!Performs the logical AND operation between the contents of register R1 and the contents of register R0 and the result is stored in the register R1.
ANDCC;6809;Condition Codes set as a direct reseult of the instruction;Logical AND Immediate Byte into CC;R' ← R ∩ IMMI!!Performs a logical AND between the condition code register and the Immediate byte specified In the instruction and places the result in the condition code register.
ASL;6809;H=? N=↕ Z=↕ V=↕ C=↕ — Value of half-carry flag is undefined;Arithmetic Memory Shift Left;C ←□□□□□□□□← 0!!Shifts all bits of the operand one place to the left. Bit zero is loaded with a zero. Bit seven is shifted into the C (carry) bit.
ASLA;6809;H=? N=↕ Z=↕ V=↕ C=↕ — Value of half-carry flag is undefined;Arithmetic A Shift Left;C ←□□□□□□□□← 0!!Shifts all bits of the operand one place to the left. Bit zero is loaded with a zero. Bit seven is shifted into the C (carry) bit.
ASLB;6809;H=? N=↕ Z=↕ V=↕ C=↕ — Value of half-carry flag is undefined;Arithmetic B Shift Left;C ←□□□□□□□□← 0!!Shifts all bits of the operand one place to the left. Bit zero is loaded with a zero. Bit seven is shifted into the C (carry) bit.
ASLD;6309;H=• N=↕ Z=↕ V=↕ C=↕;Arithmetic D Shift Left;C ←□□□□□□□□□□□□□□□□← 0!!Shifts all bits of the operand one place to the left. Bit zero is loaded with a zero. Bit fifteen is shifted into the C (carry) bit.
ASR;6809;H=? N=↕ Z=↕ V=• C=↕ — Value of half-carry flag is undefined;Arithmetic Memory Shift Right;b7 →□□□□□□□□→ C!!Shifts all bits of the operand one place to the right. Bit seven is held constant. Bit zero is shifted into the C (carry) bit.
ASRA;6809;H=? N=↕ Z=↕ V=• C=↕ — Value of half-carry flag is undefined;Arithmetic A Shift Right;b7 →□□□□□□□□→ C!!Shifts all bits of the operand one place to the right. Bit seven is held constant. Bit zero is shifted into the C (carry) bit.
ASRB;6809;H=? N=↕ Z=↕ V=• C=↕ — Value of half-carry flag is undefined;Arithmetic B Shift Right;b7 →□□□□□□□□→ C!!Shifts all bits of the operand one place to the right. Bit seven is held constant. Bit zero is shifted into the C (carry) bit.
ASRD;6309;H=• N=↕ Z=↕ V=• C=↕;Arithmetic D Shift Right;b7 →□□□□□□□□□□□□□□□□→ C!!Shifts all bits of the operand one place to the right. Bit fifteen is held constant. Bit zero is shifted into the C (carry) bit.
BCC;6809;H=• N=• Z=• V=• C=•;Branch if Carry Clear (C=0) (Unsigned);TEMP ← MI  !IFF C = 0 then PC' ← PC + TEMP!!Tests the state of the C (carry) bit and causes a branch If it Is clear.!!Equivalent to BHS.
BCS;6809;H=• N=• Z=• V=• C=•;Branch if Carry Set (C=1) (Unsigned);TEMP ← MI  !IFF C = 1 then PC' ← PC + TEMP!!Tests the state of the C (carry) bit and causes a branch If it is set.!!Equivalent to BLO.
BEQ;6809;H=• N=• Z=• V=• C=•;Branch if Equal (Z=1);TEMP ← MI  !IFF Z = 1 then PC' ← PC + TEMP!!Tests the state of the Z (zero) bit and causes a branch if it is set. When used after a subtract or compare operation, this Instruction will branch If the compared values, signed or unsigned, were exactly the same.
BGE;6809;H=• N=• Z=• V=• C=•;Branch if Greater Than or Equal to Zero (Z=1 or N XOR V=0) (Signed);TEMP ← MI  !IFF [N ⊕ V] = 0 then PC' ← PC + TEMP!!Causes a branch if the N (negative) bit and the V (overflow) bit are either both set or both clear. That is, branch if the sign of a valid twos complement result is, or would be, positive. When used after a subtract or compare operation on twos complement values, this instruction will branch if the register was greater than or equal to the memory operand.
BGT;6809;H=• N=• Z=• V=• C=•;Branch if Greater (N XOR V=0) (Signed);TEMP ← MI  !IFF Z ∩ [N ⊕ V] = 0 then PC' ← PC + TEMP!!Causes a branch if the N (negative) bit and V (overflow) bit are either both set or both clear and the Z (zero) bit is clear. In other words, branch if the sign of a valid twos complement result is, or would be, positive and not zero. When used after a subtract or compare operation on twos complement values, this instruction will branch if the register was greater than the memory operand.
BHI;6809;H=• N=• Z=• V=• C=•;Branch if Higher (Z=0 AND C=0) (Unsigned);TEMP ← MI  !IFF [C ∪ Z] = 0 then PC' ← PC + TEMP!!Causes a branch if the previous operation caused neither a carry nor a zero result. When used after a subtract or compare operation on unsigned binary values, this instruction will branch if the register was higher than the memory operand.!!Generally not useful after INC/DEC, LD/TST, and TST/CLR/COM instructions.
BHS;6809;H=• N=• Z=• V=• C=•;Branch if Higher or Same (C=0) (Unsigned);TEMP ← MI  !IFF C = 0 then PC' ← PC + TEMP!!Tests the state of the C (carry) bit and causes a branch if it is clear. When used after a subtract or compare on unsigned binary values, this instruction will branch if the register was higher than or the same as the memory operand.!!This is a duplicate assembly-language mnemonic for the single machine instruction BCC. Generally not useful after INC/DEC, LD/ST, and TST/CLR/COM instructions.
BLE;6809;H=• N=• Z=• V=• C=•;Branch if Less than or Equal to Zero (Z=1 or N XOR V=0) (Signed);TEMP ← MI  !IFF Z ∪ [N ⊕ V] = 0 then PC' ← PC + TEMP!!Causes a branch if the exclusive OR of the N (negative) and V (overflow) bits is 1 or if the Z (zero) bit is set. That is, branch if the sign of a valid twos complement result is, or would be, negative. When used after a subtract or compare operation on twos complement values, this instruction will branch if the register was less than or equal to the memory operand.
BLO;6809;H=• N=• Z=• V=• C=•;Branch if Lower (C=1) (Unsigned);TEMP ← MI  !IFF C = 1 then PC' ← PC + TEMP!!Tests the state of the (carry) bit and causes a branch if it is set. When used after a subtract or compare on unsigned binary values, this instruction will branch if the register was lower than the memory operand.!!This is a duplicate assembly-language mnemonic for the single machine instruction BCS. Generally not useful after INC/DEC.
BLS;6809;H=• N=• Z=• V=• C=•;Branch if Lower or Same (Z=1 or C=1) (Unsigned);TEMP ← MI  !IFF [C ∪ Z] = 1 then PC' ← PC + TEMP!!Causes a branch if the previous operation caused either a carry or a zero result. When used after a subtract or compare operation on unsigned binary values, this instruction will branch if the register was lower than or the same as the memory operand.!!Generally not useful after INC/DEC, LD/ST, and TST/CLR/COM instructions.
BLT;6809;H=• N=• Z=• V=• C=•;Branch if Less than Zero (N XOR V=1) (Signed);TEMP ← MI  !IFF [N ⊕ V] = 1 then PC' ← PC + TEMP!!Causes a branch if either, but not both, of the N (negative) or V (overflow) bits is set. That is, branch if the sign of a valid twos complement result is, or would be, negative. When used after a subtract or compare operation on twos complement binary values, this instruction will branch if the register was less than the memory operand.
BMI;6809;H=• N=• Z=• V=• C=•;Branch if Minus (N=1);TEMP ← MI  !IFF N = 1 then PC' ← PC + TEMP!!Tests the state of the N (negative) bit and causes a branch if set. That is, branch if the sign of the twos compiement result is negative.!!When used after an operation on signed binary values, this instruction will branch if the result is minus. It is generally preferred to use the BLT instruction after signed operations.
BNE;6809;H=• N=• Z=• V=• C=•;Branch Not Equal (Z=0);TEMP ← MI  !IFF Z = 0 then PC' ← PC + TEMP!!Tests the state of the Z (zero) bit and causes a branch if it is clear. When used after a subtract or compare operation on any binary values, this instruction will branch if the register is, or would be, not equal to the memory operand.
BPL;6809;H=• N=• Z=• V=• C=•;Branch if Plus (N=0);TEMP ← MI  !IFF N = 0 then PC' ← PC + TEMP!!Tests the state of the N (negative) bit and causes a branch if it is clear. That is, branch if the sign of the twos complement result is positive.!!When used after an operation on signed binary values, this instruction will branch if the result (possibly invalid) is positive. It is generally preferred to use the BGE instruction after signed operations.
BRA;6809;H=• N=• Z=• V=• C=•;Branch Always;TEMP ← MI  !PC' ← PC + TEMP!!Causes an unconditlonal branch.
BRN;6809;H=• N=• Z=• V=• C=•;Branch Never (NOP);TEMP ← MI!!Does not cause a branch. This instruction is essentially a no operation, but has a bit pattern logically related to branch always.
BSR;6809;H=• N=• Z=• V=• C=•;Branch to Subroutine;TEMP ← MI  !SP' ← SP-1, (SP) ← PCL  !SP' ← SP-1, (SP) ← PCH  !PC ← PC + TEMP!!The program counter is pushed onto the stack. The program counter is then loaded with the sum of the program counter and the offset.!!A return from subroutine (RTS) Instruction is used to reverse this process and must be the last instruction executed in a subroutine.
BVC;6809;H=• N=• Z=• V=• C=•;Branch if valid twos complement result (V=0);TEMP ← MI  !IFF V = 0 then PC' ← PC + TEMP!!Tests the state of the V (overflow) bit and causes a branch if it is clear. That is, branch if the twos complement result was valid. When used after an operation on twos complement binary values, this instruction will branch if there was no overflow.
BVS;6809;H=• N=• Z=• V=• C=•;Branch if invalid twos complement result (V=1);TEMP ← MI  !IFF V = 1 then PC' ← PC + TEMP!!Tests the state of the V (overflow) bit and causes a branch if it is set. That is, branch if the twos complement result was invalid. When used after an operation on twos complement binary values, this instruction will branch if there was an overflow.
BAND;6309;H=• N=• Z=• V=• C=•;Logical AND Register Bit with Memory Bit into Register Bit;R.d' ← R.d ∩ DPM.s!!Logical AND bit s of the contents of direct addressed memory location DPM into bit d of the contents of register R.
BEOR;6309;H=• N=• Z=• V=• C=•;Logical EOR Register Bit with Memory Bit into Register Bit;R.d' ← R.d ⊕ DPM.s!!Exclusive OR bit s of the contents of direct addressed memory location DPM into bit d of the contents of register R.
BIAND;6309;H=• N=• Z=• V=• C=•;Logical AND Register Bit with Inverted Memory Bit into Register Bit;R.d' ← R.d ∩ not DPM.s!!Logically AND inverted bit s of the contents of direct addressed memory location DPM into bit d of the contents of register R.
BIEOR;6309;H=• N=• Z=• V=• C=•;Logical EOR Register Bit with Inverted Memory Bit into Register Bit;R.d' ← R.d ⊕ not DPM.s!!Exclusive OR inverted bit s of the contents of direct addressed memory location DPM into bit d of the contents of register R.
BIOR;6309;H=• N=• Z=• V=• C=•;Logical OR Register Bit with Inverted Memory Bit into Register Bit;R.d' ← R.d ∪ not DPM.s!!Locially OR inverted bit s of the contents of direct addressed memory location DPM into bit d of the contents of register R.
BITA;6809;H=• N=↕ Z=↕ V=0 C=•;Bit Test with A;TEMP ← R ∩ M!!Performs the logical AND of the contents of accumulator A and the contents of memory location M and modifies the condition codes accordingly. The contents of accumulator A and memory location M are not affected.
BITB;6809;H=• N=↕ Z=↕ V=0 C=•;Bit Test with B;TEMP ← R ∩ M!!Performs the logical AND of the contents of accumulator B and the contents of memory location M and modifies the condition codes accordingly. The contents of accumulator B and memory location M are not affected.
BITD;6309;H=• N=↕ Z=↕ V=0 C=•;Bit Test with D;TEMP ← R ∩ M!!Performs the logical AND of the contents of accumulator D and the contents of memory location M and modifies the condition codes accordingly. The contents of accumulator D and memory location M are not affected.
BITMD;6309;H=• N=• Z=↕ V=• C=•;Bit Test with MD;CC.Z ← (MD.IL ∩ I.6 = 0) ∩ (MD./0 ∩ I.7 = 0)  !MD.IL' ← MD.IL ∩ not I.6  !MD./0 ← MD.0 ∩ not I.7!!Performs the logical AND of the two most-significant bits of register MD and the immediate value and modifies the Z condition code accordingly. The bits of the contents of the register MD are cleared if the corresponding bit in the immediate value is 1.
BOR;6309;H=• N=• Z=• V=• C=•;Logical OR Register Bit with Memory Bit into Register Bit;R.d' ← R.d ∪ DPM.s!!Performs an logical OR operation between the bit d of the contents of register R and the bit s of the contents of direct addressed memory location DPM and the result is stored in bit d of the contents of register R.
CLR;6809;H=• N=0 Z=1 V=0 C=0;Clear Memory;TEMP ← M  !M ← $00!!The memory location is loaded with $00. Note that the EA is read during this operation.
CLRA;6809;H=• N=0 Z=1 V=0 C=0;Clear A;R ← $00!!Accumulator A is loaded with $00.
CLRB;6809;H=• N=0 Z=1 V=0 C=0;Clear B;R ← $00!!Accumulator B is loaded with $00.
CLRD;6309;H=• N=0 Z=1 V=0 C=0;Clear D;R ← $0000!!Accumulator D is loaded with $0000.
CLRE;6309;H=• N=0 Z=1 V=0 C=0;Clear E;R ← $00!!Accumulator E is loaded with $00.
CLRF;6309;H=• N=0 Z=1 V=0 C=0;Clear F;R ← $00!!Accumulator F is loaded with $00.
CLRW;6309;H=• N=0 Z=1 V=0 C=0;Clear W;R ← $0000!!Accumulator W is loaded with $0000.
CMPA;6809;H=? N=↕ Z=↕ V=↕ C=↕ — Value of half-carry flag is undefined;Compare Memory from A;TEMP ← R - M!!Compares the contents of memory location to the contents of the specified register and sets the appropriate condition codes. Neither memory location M nor the specified register is modified. The carry flag represents a borrow and is set to the inverse of the resulting binary carry.
CMPB;6809;H=? N=↕ Z=↕ V=↕ C=↕ — Value of half-carry flag is undefined;Compare Memory from B;TEMP ← R - M!!Compares the contents of memory location to the contents of the specified register and sets the appropriate condition codes. Neither memory location M nor the specified register is modified. The carry flag represents a borrow and is set to the inverse of the resulting binary carry.
CMPD;6809;H=• N=↕ Z=↕ V=↕ C=↕;Compare Memory from D;TEMP ← R - M:M+1!!Compares the contents of memory location to the contents of the specified register and sets the appropriate condition codes. Neither memory location M nor the specified register is modified. The carry flag represents a borrow and is set to the inverse of the resulting binary carry.
CMPE;6309;H=? N=↕ Z=↕ V=↕ C=↕ — Value of half-carry flag is undefined;Compare Memory from E;TEMP ← R - M!!Compares the contents of memory location to the contents of the specified register and sets the appropriate condition codes. Neither memory location M nor the specified register is modified. The carry flag represents a borrow and is set to the inverse of the resulting binary carry.
CMPF;6309;H=? N=↕ Z=↕ V=↕ C=↕ — Value of half-carry flag is undefined;Compare Memory from F;TEMP ← R - M!!Compares the contents of memory location to the contents of the specified register and sets the appropriate condition codes. Neither memory location M nor the specified register is modified. The carry flag represents a borrow and is set to the inverse of the resulting binary carry.
CMPW;6309;H=• N=↕ Z=↕ V=↕ C=↕;Compare Memory from W;TEMP ← R - M:M+1!!Compares the contents of memory location to the contents of the specified register and sets the appropriate condition codes. Neither memory location M nor the specified register is modified. The carry flag represents a borrow and is set to the inverse of the resulting binary carry.
CMPX;6809;H=• N=↕ Z=↕ V=↕ C=↕;Compare Memory from X;TEMP ← R - M:M+1!!Compares the contents of memory location to the contents of the specified register and sets the appropriate condition codes. Neither memory location M nor the specified register is modified. The carry flag represents a borrow and is set to the inverse of the resulting binary carry.
CMPY;6809;H=• N=↕ Z=↕ V=↕ C=↕;Compare Memory from Y;TEMP ← R - M:M+1!!Compares the contents of memory location to the contents of the specified register and sets the appropriate condition codes. Neither memory location M nor the specified register is modified. The carry flag represents a borrow and is set to the inverse of the resulting binary carry.
CMPR;6309;H=• N=↕ Z=↕ V=↕ C=↕;Compare Register from Register;TEMP ← R1 - R0!!Compares the contents of register R1 to the contents of the register R0 and sets the appropriate condition codes. Neither register is modified. The carry flag represents a borrow and is set to the inverse of the resulting binary carry.
CMPS;6809;H=• N=↕ Z=↕ V=↕ C=↕;Compare Memory from S;TEMP ← R - M:M+1!!Compares the contents of memory location to the contents of the specified register and sets the appropriate condition codes. Neither memory location M nor the specified register is modified. The carry flag represents a borrow and is set to the inverse of the resulting binary carry.
CMPU;6809;H=• N=↕ Z=↕ V=↕ C=↕;Compare Memory from U;TEMP ← R - M:M+1!!Compares the contents of memory location to the contents of the specified register and sets the appropriate condition codes. Neither memory location M nor the specified register is modified. The carry flag represents a borrow and is set to the inverse of the resulting binary carry.
COM;6809;H=• N=↕ Z=↕ V=0 C=1;Complement Memory;M' ← 0 + M̅!!Replaces the contents of memory location M or accumulator A or B with its logical complement. When operating on unsigned values, only BEQ and BNE branches can be expected to behave properly following a COM instruction. When operating on twos complement values, all signed branches are available.
COMA;6809;H=• N=↕ Z=↕ V=0 C=1;Complement A;R' ← 0 + R̅!!Replaces the contents of memory location M or accumulator A or B with its logical complement. When operating on unsigned values, only BEQ and BNE branches can be expected to behave properly following a COM instruction. When operating on twos complement values, all signed branches are available.
COMB;6809;H=• N=↕ Z=↕ V=0 C=1;Complement B;R' ← 0 + R̅!!Replaces the contents of memory location M or accumulator A or B with its logical complement. When operating on unsigned values, only BEQ and BNE branches can be expected to behave properly following a COM instruction. When operating on twos complement values, all signed branches are available.
COMD;6309;H=• N=↕ Z=↕ V=0 C=1;Complement D;R' ← 0 + R̅!!Replaces the contents of memory location M or accumulator A or B with its logical complement. When operating on unsigned values, only BEQ and BNE branches can be expected to behave properly following a COM instruction. When operating on twos complement values, all signed branches are available.
COME;6309;H=• N=↕ Z=↕ V=0 C=1;Complement E;R' ← 0 + R̅!!Replaces the contents of memory location M or accumulator A or B with its logical complement. When operating on unsigned values, only BEQ and BNE branches can be expected to behave properly following a COM instruction. When operating on twos complement values, all signed branches are available.
COMF;6309;H=• N=↕ Z=↕ V=0 C=1;Complement F;R' ← 0 + R̅!!Replaces the contents of memory location M or accumulator A or B with its logical complement. When operating on unsigned values, only BEQ and BNE branches can be expected to behave properly following a COM instruction. When operating on twos complement values, all signed branches are available.
COMW;6309;H=• N=↕ Z=↕ V=0 C=1;Complement W;R' ← 0 + R̅!!Replaces the contents of memory location M or accumulator A or B with its logical complement. When operating on unsigned values, only BEQ and BNE branches can be expected to behave properly following a COM instruction. When operating on twos complement values, all signed branches are available.
CWAI;6809;Condition Codes set as a direct reseult of the instruction;Clear CC bit's and Wait for Interrupt;CCR' ← CCR ∩ IMM (Possibly clear masks)  !Set E (entire state saved)  !SP' ← SP-1, (SP) ← PCL  !SP ←  SP-1, (SP) ← PCH  !SP' ← SP-1, (SP) ← USL  !SP ← SP-1, (SP) ← USH  !SP ← SP-1, (SP) ← IYL  !SP' ← SP-1, (SP) ← IYH  !SP' ← SP-1, (SP) ← IXL  !SP' ← SP-1, (SP) ← IXH  !SP' ← SP-1, (SP) ← DPR  !SP' ← SP-1, (SP) ← ACCB  !SP' ← SP-1, (SP) ← ACCA  !SP' ← SP-1, (SP) ← CCR!!This instruction ANDs an immediate byte with the condition code register which may clear the interrupt mask bits I and F, stacks the entire machine state on the hardware stack and then looks for an interrupt. When a non-masked interrupt occurs, no further machine state information need be saved before vectoring to the interrupt handling routine. This instruction replaced the MC6800 CLI WAI sequence, but does not place the buses in a high-impedance state. A F̅I̅R̅Q̅ (fast interrupt request) may enter its interrupt handler with its entire machine state saved. The RTI (return from interrupt) instruction will automatically return the entire machine state after testing the E (entire) bit of the recovered condition code register.!!The following immediate values will have the following results:!!FF = enable neither  !EF = enable F̅R̅Q̅  !BF = enable F̅I̅R̅Q̅  !AF = enable both
DAA;6809;H=• N=↕ Z=↕ V=0 C=↕;Decimal Addition Adjust;ACCA' ← ACCA + CF(MSN):CF(LSN)  !where CF is a Correction Factor, as follows: the CF for each nibble (BCD) digit is determined separately, and is either 6 or 0.!!**Least Significant Nibble**!!| | |!| ---: | :---|!| CF(LSN) = 6 IFF |  1) C = 1 |!| or | 2) LSN>9 |!!**Most Significant Nibble**!!| | |!| ---: | :---|!| CF(MSN) = 6 IFF | 1) C = 1 |!| or | 2) MSN > 9 |!| or | 3) MSN > 8 *and* LSN > 9 |!!The sequence of a single-byte add instruction on accumulator A (either ADDA or ADCA) and a following decimal addition adjust instruction results in a BCD addition with an appropriate carry bit. Both values to be added must be in proper BCD form (each nibble such that: 0 < nibble < 9). Multiple-precision addition must add the carry generated by this decimal addition adjust into the next higher digit during the add operation (ADCA) immediately prior to the next decimal addition adjust.
DEC;6809;H=• N=↕ Z=↕ V=↕ C=•;Decrement;M' ← M - 1!!Subtract one from the operand. The carry bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only BEQ and BNE branches can be expected to behave consistently. When operating on twos complement values, all signed branches are available.
DECA;6809;H=• N=↕ Z=↕ V=↕ C=•;Decrement A;R' ← R - 1!!Subtract one from the operand. The carry bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only BEQ and BNE branches can be expected to behave consistently. When operating on twos complement values, all signed branches are available.
DECB;6809;H=• N=↕ Z=↕ V=↕ C=•;Decrement B;R' ← R - 1!!Subtract one from the operand. The carry bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only BEQ and BNE branches can be expected to behave consistently. When operating on twos complement values, all signed branches are available.
DECD;6309;H=• N=↕ Z=↕ V=↕ C=•;Decrement D;R' ← R - 1!!Subtract one from the operand. The carry bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only BEQ and BNE branches can be expected to behave consistently. When operating on twos complement values, all signed branches are available.
DECE;6309;H=• N=↕ Z=↕ V=↕ C=•;Decrement E;R' ← R - 1!!Subtract one from the operand. The carry bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only BEQ and BNE branches can be expected to behave consistently. When operating on twos complement values, all signed branches are available.
DECF;6309;H=• N=↕ Z=↕ V=↕ C=•;Decrement F;R' ← R - 1!!Subtract one from the operand. The carry bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only BEQ and BNE branches can be expected to behave consistently. When operating on twos complement values, all signed branches are available.
DECW;6309;H=• N=↕ Z=↕ V=↕ C=•;Decrement W;R' ← R - 1!!Subtract one from the operand. The carry bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only BEQ and BNE branches can be expected to behave consistently. When operating on twos complement values, all signed branches are available.
DIVD;6309;H=• N=↕ Z=↕ V=↕ C=↕;Signed Divide D by Memory;B' ← D ÷ M  !A' ← D mod M!!Divide the signed 16-bit contents of accumulator D (dividend) by the 8-bit contents of memory location M, place the 8-bit quotient into accumulator B and the 8-bit remainder in accumulator A. The sign of the remainder is always the same as the sign of the dividend unless the remainder is zero. If the contents of memory location M is zero, a Division-By-Zero exception is triggered (set bit 7 of the contents of the register MD, push the state onto the hardware stack, and jump to the illegal instruction vector).
DIVQ;6309;H=• N=↕ Z=↕ V=↕ C=↕;Signed Divide Q by Memory;W' ← Q ÷ M:M+1  !D' ← Q mod M:M+1!!Divide the signed 32-bit contents of accumulator Q (dividend) by the 16-bit contents of memory location M (divisor), place the 16-bit quotient into accumulator W and the 16-bit remainder in accumulator D. The sign of the remainder is always the same as the sign of the dividend unless the remainder is zero. If the contents of memory location M is zero, a Division-By-Zero exception is triggered (set bit 7 of the contents of the register MD, push the state onto the hardware stack, and jump to the illegal instruction vector).
EIM;6309;H=• N=↕ Z=↕ V=0 C=•;Logical EOR of Value into Memory;M' ← M ⊕ I!!The immediate value is exclusive ORed into memory location M.
EORA;6809;H=• N=↕ Z=↕ V=0 C=•;Exclusive OR Memory into A;R' ← R ⊕ M!!The contents of memory location M is exclusive ORed into an 8-blt register.
EORB;6809;H=• N=↕ Z=↕ V=0 C=•;Exclusive OR Memory into B;R' ← R ⊕ M!!The contents of memory location M is exclusive ORed into an 8-blt register.
EORD;6309;H=• N=↕ Z=↕ V=0 C=•;Exclusive OR Memory into D;R' ← R ⊕ M:M+1!!The contents of memory location M:M+1 is exclusive ORed into the 16-blt register.
EORR;6309;H=• N=↕ Z=↕ V=0 C=•;Exclusive OR Register into Register;R1' ← R0 ⊕ R1!!The contents of register R0 is exclusive ORed into the register R1.
EXG;6809;H=• N=• Z=• V=• C=•;Exchange Registers;R1 ↔ R2!!Exchanges data between two designated registers. Only like size registers may be exchanged. (8-bit with 8-bit or 16-bit with 16-bit.)
INC;6809;H=• N=↕ Z=↕ V=↕ C=•;Increment Memory;M' ← M + 1!!Adds to the operand. The carry bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only the BEQ and BNE branches can be expected to behave consistently. When operating on twos complement values, all signed branches are correctly available.
INCA;6809;H=• N=↕ Z=↕ V=↕ C=•;Increment A;R' ← R + 1!!Adds to the operand. The carry bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only the BEQ and BNE branches can be expected to behave consistently. When operating on twos complement values, all signed branches are correctly available.
INCB;6809;H=• N=↕ Z=↕ V=↕ C=•;Increment B;R' ← R + 1!!Adds to the operand. The carry bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only the BEQ and BNE branches can be expected to behave consistently. When operating on twos complement values, all signed branches are correctly available.
INCD;6309;H=• N=↕ Z=↕ V=↕ C=•;Increment D;R' ← R + 1!!Adds to the operand. The carry bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only the BEQ and BNE branches can be expected to behave consistently. When operating on twos complement values, all signed branches are correctly available.
INCE;6309;H=• N=↕ Z=↕ V=↕ C=•;Increment E;R' ← R + 1!!Adds to the operand. The carry bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only the BEQ and BNE branches can be expected to behave consistently. When operating on twos complement values, all signed branches are correctly available.
INCF;6309;H=• N=↕ Z=↕ V=↕ C=•;Increment F;R' ← R + 1!!Adds to the operand. The carry bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only the BEQ and BNE branches can be expected to behave consistently. When operating on twos complement values, all signed branches are correctly available.
INCW;6309;H=• N=↕ Z=↕ V=↕ C=•;Increment W;R' ← R + 1!!Adds to the operand. The carry bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. When operating on unsigned values, only the BEQ and BNE branches can be expected to behave consistently. When operating on twos complement values, all signed branches are correctly available.
JMP;6809;H=• N=• Z=• V=• C=•;Jump;PC' ← EA!!Program control is transferred to the effective address.
JSR;6809;H=• N=• Z=• V=• C=•;Jump to Subroutine;SP' ← SP - 1, (SP) ← PCL  !SP' ← SP - 1, (SP) ← PCH  !PC ← EA!!Program control is transferred to the effective address after storing the return address on the hardware stack. A RTS instruction should be the last executed instruction of the subroutine.
LBCC;6809;H=• N=• Z=• V=• C=•;Long Branch if Carry Clear (C=0) (Unsigned);TEMP ← MI  !IFF C = 0 then PC' ← PC + TEMP!!Tests the state of the C (carry) bit and causes a branch If it Is clear.!!Equivalent to LBHS.
LBCS;6809;H=• N=• Z=• V=• C=•;Long Branch if Carry Set (C=1) (Unsigned);TEMP ← MI  !IFF C = 1 then PC' ← PC + TEMP!!Tests the state of the C (carry) bit and causes a branch If it is set.!!Equivalent to LBLO.
LBEQ;6809;H=• N=• Z=• V=• C=•;Long Branch if Equal (Z=1);TEMP ← MI  !IFF Z = 1 then PC' ← PC + TEMP!!Tests the state of the Z (zero) bit and causes a branch if it is set. When used after a subtract or compare operation, this Instruction will branch If the compared values, signed or unsigned, were exactly the same.
LBGE;6809;H=• N=• Z=• V=• C=•;Long Branch if Greater Than or Equal to Zero (Z=1 or N XOR V=0) (Signed);TEMP ← MI  !IFF [N ⊕ V] = 0 then PC' ← PC + TEMP!!Causes a branch if the N (negative) bit and the V (overflow) bit are either both set or both clear. That is, branch if the sign of a valid twos complement result is, or would be, positive. When used after a subtract or compare operation on twos complement values, this instruction will branch if the register was greater than or equal to the memory operand.
LBGT;6809;H=• N=• Z=• V=• C=•;Long Branch if Greater (N XOR V=0) (Signed);TEMP ← MI  !IFF Z ∩ [N ⊕ V] = 0 then PC' ← PC + TEMP!!Causes a branch if the N (negative) bit and V (overflow) bit are either both set or both clear and the Z (zero) bit is clear. In other words, branch if the sign of a valid twos complement result is, or would be, positive and not zero. When used after a subtract or compare operation on twos complement values, this instruction will branch if the register was greater than the memory operand.
LBHI;6809;H=• N=• Z=• V=• C=•;Long Branch if Higher (Z=0 AND C=0) (Unsigned);TEMP ← MI  !IFF [C ∪ Z] = 0 then PC' ← PC + TEMP!!Causes a branch if the previous operation caused neither a carry nor a zero result. When used after a subtract or compare operation on unsigned binary values, this instruction will branch if the register was higher than the memory operand.!!Generally not useful after INC/DEC, LD/TST, and TST/CLR/COM instructions.
LBHS;6809;H=• N=• Z=• V=• C=•;Long Branch if Higher or Same (C=0) (Unsigned);TEMP ← MI  !IFF C = 0 then PC' ← PC + TEMP!!Tests the state of the C (carry) bit and causes a branch if it is clear. When used after a subtract or compare on unsigned binary values, this instruction will branch if the register was higher than or the same as the memory operand.!!This is a duplicate assembly-language mnemonic for the single machine instruction LBCC. Generally not useful after INC/DEC, LD/ST, and TST/CLR/COM instructions.
LBLE;6809;H=• N=• Z=• V=• C=•;Long Branch if Less than or Equal to Zero (Z=1 or N XOR V=0) (Signed);TEMP ← MI  !IFF Z ∪ [N ⊕ V] = 0 then PC' ← PC + TEMP!!Causes a branch if the exclusive OR of the N (negative) and V (overflow) bits is 1 or if the Z (zero) bit is set. That is, branch if the sign of a valid twos complement result is, or would be, negative. When used after a subtract or compare operation on twos complement values, this instruction will branch if the register was less than or equal to the memory operand.
LBLO;6809;H=• N=• Z=• V=• C=•;Long Branch if Lower (C=1) (Unsigned);TEMP ← MI  !IFF C = 1 then PC' ← PC + TEMP!!Tests the state of the (carry) bit and causes a branch if it is set. When used after a subtract or compare on unsigned binary values, this instruction will branch if the register was lower than the memory operand.!!This is a duplicate assembly-language mnemonic for the single machine instruction LBCS. Generally not useful after INC/DEC.
LBLS;6809;H=• N=• Z=• V=• C=•;Long Branch if Lower or Same (Z=1 or C=1) (Unsigned);TEMP ← MI  !IFF [C ∪ Z] = 1 then PC' ← PC + TEMP!!Causes a branch if the previous operation caused either a carry or a zero result. When used after a subtract or compare operation on unsigned binary values, this instruction will branch if the register was lower than or the same as the memory operand.!!Generally not useful after INC/DEC, LD/ST, and TST/CLR/COM instructions.
LBLT;6809;H=• N=• Z=• V=• C=•;Long Branch if Less than Zero (N XOR V=1) (Signed);TEMP ← MI  !IFF [N ⊕ V] = 1 then PC' ← PC + TEMP!!Causes a branch if either, but not both, of the N (negative) or V (overflow) bits is set. That is, branch if the sign of a valid twos complement result is, or would be, negative. When used after a subtract or compare operation on twos complement binary values, this instruction will branch if the register was less than the memory operand.
LBMI;6809;H=• N=• Z=• V=• C=•;Long Branch if Minus (N=1);TEMP ← MI  !IFF N = 1 then PC' ← PC + TEMP!!Tests the state of the N (negative) bit and causes a branch if set. That is, branch if the sign of the twos compiement result is negative.!!When used after an operation on signed binary values, this instruction will branch if the result is minus. It is generally preferred to use the LBLT instruction after signed operations.
LBNE;6809;H=• N=• Z=• V=• C=•;Long Branch Not Equal (Z=0);TEMP ← MI  !IFF Z = 0 then PC' ← PC + TEMP!!Tests the state of the Z (zero) bit and causes a branch if it is clear. When used after a subtract or compare operation on any binary values, this instruction will branch if the register is, or would be, not equal to the memory operand.
LBPL;6809;H=• N=• Z=• V=• C=•;Long Branch if Plus (N=0);TEMP ← MI  !IFF N = 0 then PC' ← PC + TEMP!!Tests the state of the N (negative) bit and causes a branch if it is clear. That is, branch if the sign of the twos complement result is positive.!!When used after an operation on signed binary values, this instruction will branch if the result (possibly invalid) is positive. It is generally preferred to use the LBGE instruction after signed operations.
LBRA;6809;H=• N=• Z=• V=• C=•;Long Branch Always;TEMP ← MI  !!PC' ← PC + TEMP!!Causes an unconditlonai branch.
LBRN;6809;H=• N=• Z=• V=• C=•;Long Branch Never (NOP);TEMP ← MI!!Does not cause a branch. This instruction is essentially a no operation, but has a bit pattern logically related to branch always.
LBSR;6809;H=• N=• Z=• V=• C=•;Long Branch to Subroutine;TEMP ← MI  !SP' ← SP-1, (SP) ← PCL  !SP' ← SP-1, (SP) ← PCH  !PC ← PC + TEMP!!The program counter is pushed onto the stack. The program counter is then loaded with the sum of the program counter and the offset.!!A return from subroutine (RTS) Instruction is used to reverse this process and must be the last instruction executed in a subroutine.
LBVC;6809;H=• N=• Z=• V=• C=•;Long Branch if valid twos complement result (V=0);TEMP ← MI  !IFF V = 0 then PC' ← PC + TEMP!!Tests the state of the V (overflow) bit and causes a branch if it is clear. That is, branch if the twos complement result was valid. When used after an operation on twos complement binary values, this instruction will branch if there was no overflow.
LBVS;6809;H=• N=• Z=• V=• C=•;Long Branch if invalid twos complement result (V=1);TEMP ← MI  !IFF V = 1 then PC' ← PC + TEMP!!Tests the state of the V (overflow) bit and causes a branch if it is set. That is, branch if the twos complement result was invalid. When used after an operation on twos complement binary values, this instruction will branch if there was an overflow.
LDA;6809;H=• N=↕ Z=↕ V=0 C=•;Load A from Memory;R' ← M!!Loads the contents of memory location M into the designated register.
LDB;6809;H=• N=↕ Z=↕ V=0 C=•;Load B from Memory;R' ← M!!Loads the contents of memory location M into the designated register.
LDD;6309;H=• N=↕ Z=↕ V=0 C=•;Load D from Memory;R' ← M:M+1!!Load the contents of the memory location M:M+1 into the designated 16-bit register.
LDE;6309;H=• N=↕ Z=↕ V=0 C=•;Load E from Memory;R' ← M!!Loads the contents of memory location M into the designated register.
LDF;6309;H=• N=↕ Z=↕ V=0 C=•;Load F from Memory;R' ← M!!Loads the contents of memory location M into the designated register.
LDW;6309;H=• N=↕ Z=↕ V=0 C=•;Load W from Memory;R' ← M:M+1!!Load the contents of the memory location M:M+1 into the designated 16-bit register.
LDX;6809;H=• N=↕ Z=↕ V=0 C=•;Load X from Memory;R' ← M:M+1!!Load the contents of the memory location M:M+1 into the designated 16-bit register.
LDY;6809;H=• N=↕ Z=↕ V=0 C=•;Load Y from Memory;R' ← M:M+1!!Load the contents of the memory location M:M+1 into the designated 16-bit register.
LDS;6809;H=• N=↕ Z=↕ V=0 C=•;Load S from Memory;R' ← M:M+1!!Load the contents of the memory location M:M+1 into the designated 16-bit register.
LDU;6809;H=• N=↕ Z=↕ V=0 C=•;Load U from Memory;R' ← M:M+1!!Load the contents of the memory location M:M+1 into the designated 16-bit register.
LDBT;6309;H=• N=• Z=• V=• C=•;Load Register Bit from Memory;R.d' ← DPM.s!!Load bit s of the contents of direct address memory location DPM into bit d of the register R. No condition codes are affected.
LDMD;6309;H=• N=• Z=• V=• C=•;Load Value into MD;MD.NM' ← I.0  !MD.FM ← I.1!!Loads the native mode and FIRQ mode bits (two least-significant bits) of the immediate value into the register MD. No condition codes are affected.
LDQ;6309;H=• N=↕ Z=↕ V=0 C=•;Load Q from Memory;Q! ← M:M+3!!Load the contents of the memory location M:M+3 into the designated 32-bit register.
LEAX;6809;H=• N=• Z=↕ V=• C=•;Load Effective Address into X;R' ← EA!!Calculates the effective address from the indexed addressing and places the address in an indexable register.!!LEAX affects the Z (zero) bit to allow use of these registers as counters and for MC6800 INX/DEX compatibility.!!Due to the order in which effective addresses are calculated internally, the LEAX ,X++ and LEAX ,X+ do not add 2 and 1 (respectively) to the X register, but instead leave the X register unchanged. This also applies to the Y, U, and S registers. For the expected results, use the faster instruction LEAX 2,X and LEAX 1,X.!!Some examples of LEA instruction uses are given in the following table.!!| Instruction | Operation | Comment |!| :--- | :--- | :--- |!| LEAX 10,X | X + 10 → X | Adds 5-bit constant 10 to X |!| LEAX 500,X | X + 500 → X | Adds 16-bit constant 500 to X |!| LEAY A,Y | Y + A → Y | Adds 8-bit accumulator to Y |!| LEAY D,Y | Y + D → Y | Adds 16-bit D accumulator to Y |!| LEAU -10,U | U - 10 → U | Subtracts 10 from U |!| LEAS -10,S | S - 10 → S | Used to reserve area on stack |!| LEAS 10,S | S + 10 → S | Used to 'clean up' stack |!| LEAX 5,S | S + 5 → X | Transfers as well as adds |
LEAY;6809;H=• N=• Z=↕ V=• C=•;Load Effective Address into Y;R' ← EA!!Calculates the effective address from the indexed addressing and places the address in an indexable register.!!LEAY affects the Z (zero) bit to allow use of these registers as counters and for MC6800 INX/DEX compatibility.!!Due to the order in which effective addresses are calculated internally, the LEAX ,X++ and LEAX ,X+ do not add 2 and 1 (respectively) to the X register, but instead leave the X register unchanged. This also applies to the Y, U, and S registers. For the expected results, use the faster instruction LEAX 2,X and LEAX 1,X.!!Some examples of LEA instruction uses are given in the following table.!!| Instruction | Operation | Comment |!| :--- | :--- | :--- |!| LEAX 10,X | X + 10 → X | Adds 5-bit constant 10 to X |!| LEAX 500,X | X + 500 → X | Adds 16-bit constant 500 to X |!| LEAY A,Y | Y + A → Y | Adds 8-bit accumulator to Y |!| LEAY D,Y | Y + D → Y | Adds 16-bit D accumulator to Y |!| LEAU -10,U | U - 10 → U | Subtracts 10 from U |!| LEAS -10,S | S - 10 → S | Used to reserve area on stack |!| LEAS 10,S | S + 10 → S | Used to 'clean up' stack |!| LEAX 5,S | S + 5 → X | Transfers as well as adds |
LEAS;6809;H=• N=• Z=• V=• C=•;Load Effective Address into S;R' ← EA!!Calculates the effective address from the indexed addressing and places the address in an indexable register.!!LEAS does not affect the Z bit to allow cleaning up the stack while returning the Z bit as a parameter to a calling routine, and also for MC6800 INS/DES compatibility.!!Due to the order in which effective addresses are calculated internally, the LEAX ,X++ and LEAX ,X+ do not add 2 and 1 (respectively) to the X register, but instead leave the X register unchanged. This also applies to the Y, U, and S registers. For the expected results, use the faster instruction LEAX 2,X and LEAX 1,X.!!Some examples of LEA instruction uses are given in the following table.!!| Instruction | Operation | Comment |!| :--- | :--- | :--- |!| LEAX 10,X | X + 10 → X | Adds 5-bit constant 10 to X |!| LEAX 500,X | X + 500 → X | Adds 16-bit constant 500 to X |!| LEAY A,Y | Y + A → Y | Adds 8-bit accumulator to Y |!| LEAY D,Y | Y + D → Y | Adds 16-bit D accumulator to Y |!| LEAU -10,U | U - 10 → U | Subtracts 10 from U |!| LEAS -10,S | S - 10 → S | Used to reserve area on stack |!| LEAS 10,S | S + 10 → S | Used to 'clean up' stack |!| LEAX 5,S | S + 5 → X | Transfers as well as adds |
LEAU;6809;H=• N=• Z=• V=• C=•;Load Effective Address into U;R' ← EA!!Calculates the effective address from the indexed addressing and places the address in an indexable register.!!LEAU does not affect the Z bit to allow cleaning up the stack while returning the Z bit as a parameter to a calling routine, and also for MC6800 INS/DES compatibility.!!Due to the order in which effective addresses are calculated internally, the LEAX ,X++ and LEAX ,X+ do not add 2 and 1 (respectively) to the X register, but instead leave the X register unchanged. This also applies to the Y, U, and S registers. For the expected results, use the faster instruction LEAX 2,X and LEAX 1,X.!!Some examples of LEA instruction uses are given in the following table.!!| Instruction | Operation | Comment |!| :--- | :--- | :--- |!| LEAX 10,X | X + 10 → X | Adds 5-bit constant 10 to X |!| LEAX 500,X | X + 500 → X | Adds 16-bit constant 500 to X |!| LEAY A,Y | Y + A → Y | Adds 8-bit accumulator to Y |!| LEAY D,Y | Y + D → Y | Adds 16-bit D accumulator to Y |!| LEAU -10,U | U - 10 → U | Subtracts 10 from U |!| LEAS -10,S | S - 10 → S | Used to reserve area on stack |!| LEAS 10,S | S + 10 → S | Used to 'clean up' stack |!| LEAX 5,S | S + 5 → X | Transfers as well as adds |
LSL;6809;H=• N=↕ Z=↕ V=↕ C=↕;Logical Memory Shift Left;C ←□□□□□□□□← 0!!Shifts all bits of memory location M one place to the left. Bit zero is loaded with a zero. Bit seven of memory location M is shifted into the (carry) bit.!!This is a duplicate assembly-language mnemonic for the single machine instruction ASL.
LSLA;6809;H=• N=↕ Z=↕ V=↕ C=↕;Logical A Shift Left;C ←□□□□□□□□← 0!!Shifts all bits of accumulator A one place to the left. Bit zero is loaded with a zero. Bit seven of accumulator A is shifted into the (carry) bit.!!This is a duplicate assembly-language mnemonic for the single machine instruction ASL.
LSLB;6809;H=• N=↕ Z=↕ V=↕ C=↕;Logical B Shift Left;C ←□□□□□□□□← 0!!Shifts all bits of accumulator B one place to the left. Bit zero is loaded with a zero. Bit seven of accumulator B is shifted into the (carry) bit.!!This is a duplicate assembly-language mnemonic for the single machine instruction ASL.
LSLD;6309;H=• N=↕ Z=↕ V=↕ C=↕;Logical D Shift Left;C ←□□□□□□□□□□□□□□□□← 0!!Shifts all bits of accumulator D one place to the left. Bit zero is loaded with a zero. Bit fifteen of accumulator D is shifted into the (carry) bit.!!This is a duplicate assembly-language mnemonic for the single machine instruction ASL.
LSR;6809;H=• N=0 Z=↕ V=• C=↕;Logical Memory Shift Right;0 →□□□□□□□□→ C!!Performs a logical shift right on the operand. Shifts a zero into bit seven and bit zero into the C (carry) bit.
LSRA;6809;H=• N=0 Z=↕ V=• C=↕;Logical A Shift Right;0 →□□□□□□□□→ C!!Performs a logical shift right on the operand. Shifts a zero into bit seven and bit zero into the C (carry) bit.
LSRB;6809;H=• N=0 Z=↕ V=• C=↕;Logical B Shift Right;0 →□□□□□□□□→ C!!Performs a logical shift right on the operand. Shifts a zero into bit seven and bit zero into the C (carry) bit.
LSRD;6309;H=• N=0 Z=↕ V=• C=↕;Logical D Shift Right;0 →□□□□□□□□□□□□□□□□→ C!!Performs a logical shift right on the operand. Shifts a zero into bit fifteen and bit zero into the C (carry) bit.
LSRW;6309;H=• N=0 Z=↕ V=• C=↕;Logical W Shift Right;0 →□□□□□□□□□□□□□□□□→ C!!Performs a logical shift right on the operand. Shifts a zero into bit fifteen and bit zero into the C (carry) bit.
MUL;6809;H=• N=• Z=↕ V=• C=? — Special case — Carry set if b7 is SET;Unsigned Multiply into D;A':B' ← A × B!!Multiply the unsigned contents accumulators A and B, place the result in both accumulators (the contents of accumulator A contains the most-significant byte of the result). Unsigned multiply allows multiple-precision operations.!!The C (carry) bit allows rounding the most-significant byte through the sequence: MUL, ADCA #0.
MULD;6309;H=• N=↕ Z=↕ V=• C=•;Signed Multiply into Q;Q' ← D × I|M:M+1!!Multiply the signed contents of accumulators D and the contents of a 16-bit immediate value or the contents of memory location M, place the result in accumulator Q.
NEG;6809;H=? N=↕ Z=↕ V=↕ C=↕ — Value of half-carry flag is undefined;Negate Memory;M' ← 0 - M!!Replaces the operand with its twos complement. The (carry) bit represents a borrow and is set to the inverse of the resulting binary carry. Note that $0080 is replaced by itself and only in this case is the V (overflow) bit set. The value $0000 is also replaced by itself, and only in this case is the C (carry) bit cleared.
NEGA;6809;H=? N=↕ Z=↕ V=↕ C=↕ — Value of half-carry flag is undefined;Negate A;R' ← 0 - R!!Replaces the operand with its twos complement. The (carry) bit represents a borrow and is set to the inverse of the resulting binary carry. Note that $0080 is replaced by itself and only in this case is the V (overflow) bit set. The value $0000 is also replaced by itself, and only in this case is the C (carry) bit cleared.
NEGB;6809;H=? N=↕ Z=↕ V=↕ C=↕ — Value of half-carry flag is undefined;Negate B;R' ← 0 - R!!Replaces the operand with its twos complement. The (carry) bit represents a borrow and is set to the inverse of the resulting binary carry. Note that $0080 is replaced by itself and only in this case is the V (overflow) bit set. The value $0000 is also replaced by itself, and only in this case is the C (carry) bit cleared.
NEGD;6809;H=• N=↕ Z=↕ V=↕ C=↕;Negate D;R' ← 0 - R!!Replaces the operand with its twos complement. The (carry) bit represents a borrow and is set to the inverse of the resulting binary carry. Note that $8000 is replaced by itself and only in this case is the V (overflow) bit set. The value $0000 is also replaced by itself, and only in this case is the C (carry) bit cleared.
NOP;6809;H=• N=• Z=• V=• C=•;No Operation;This instruction causes only the program counter to be incremented. No other registers or memory locations are affected.
OIM;6309;H=• N=↕ Z=↕ V=0 C=•;Logical OR Value into Memory;M! ← M ∪ I!!Performs an inclusive OR operation between the contents of memory location M and the immediate value I and the result is stored in the memory location M.
ORA;6809;H=• N=↕ Z=↕ V=0 C=•;Inclusive OR Memory into A;R' ← R ∪ M!!Performs an inclusive OR operation between the contents of accumulator A and the contents of memory location M and the result is stored in accumulator A.
ORB;6809;H=• N=↕ Z=↕ V=0 C=•;Inclusive OR Memory into B;R' ← R ∪ M!!Performs an inclusive OR operation between the contents of accumulator B and the contents of memory location M and the result is stored in accumulator B.
ORCC;6809;Condition Codes set as a direct reseult of the instruction;Inclusive OR Immediate Byte into CC;R'— R ∪ IMM!!Performs an inclusive OR operation between the contents of the condition code registers and the immediate value, and the result is piaced in the condition code register. This instruction may be used to set interrupt masks (disable interrupts) or any other bit(s).
ORD;6309;H=• N=↕ Z=↕ V=0 C=•;Inclusive OR Memory into D;R' ← R ∪ M:M+1!!Performs an inclusive OR operation between the contents of accumulator B and the contents of memory location M:M+1 and the result is stored in accumulator D.
ORR;6309;H=• N=↕ Z=↕ V=0 C=•;Inclusive OR Register into Register;R1' ← R1 ∪ R0!!Performs an inclusive OR operation between the contents of register R0 and the contents of register R1 and the result is stored in register R1.
PSHS;6809;H=• N=• Z=• V=• C=•;Push Registers onto Hardware Stack;**Push Order**  !PC ⇢ U ⇢ Y ⇢ X ⇢ DP ⇢ B ⇢ A ⇢ CC!!All, some, or none of the processor registers are pushed onto the hardware stack (with the exception of the hardware stack pointer itself).!!A single register may be placed on the stack with the condition codes set by doing an autodecrement store onto the stack (example: STX ,--S).
PSHSW;6309;H=• N=• Z=• V=• C=•;Push W onto Hardware Stack;S' ← S - 2  !S:S+1' ← W!!Autodecrements the contents of the hardware stack register and pushs the value of the register W (E and F) onto the hardware stack. Condition codes are not affected.
PSHU;6809;H=• N=• Z=• V=• C=•;Push Registers onto User Stack;**Push Order**  !PC ⇢ S ⇢ Y ⇢ X ⇢ DP ⇢ B ⇢ A ⇢ CC!!All, some, or none of the processor registers are pushed onto the user stack (with the exception of the user stack pointer itself).!!A single register may be placed on the stack with the condition codes set by doing an autodecrement store onto the stack (example: STX ,--U).
PSHUW;6309;H=• N=• Z=• V=• C=•;Push W onto User Stack;U' ← U - 2  !U:U+1' ← W!!Autodecrements the contents of the user stack register and pushs the value of the register W (E and F) onto the user stack. Condition codes are not affected.
PULS;6809;H=• N=• Z=• V=• C=•;Pull Registers from Hardware Stack;**Pull Order**  !PC ⇠ U ⇠ Y ⇠ X ⇠ DP ⇠ B ⇠ A ⇠ CC!!All, some, or none of the processor registers are pulled from the hardware stack (with the exception of the hardware stack pointer itself).!!A single register may be pulled from the stack with condition codes set by doing an autoincrement load from the stack (example: LDX ,S++).
PULSW;6309;H=• N=• Z=• V=• C=•;Pull W from Hardware Stack;W' ← S:S+1  !S' ← S + 2!!Pulls the value for register W (E and F) from the hardware stack and autoincrements the contents of the hardware stack register. Condition codes are not affected.
PULU;6809;H=• N=• Z=• V=• C=•;Pull Registers from User Stack;**Pull Order**  !PC ⇠ S ⇠ Y ⇠ X ⇠ DP ⇠ B ⇠ A ⇠ CC!!All, some, or none of the processor registers are pulled from the user stack (with the exception of the user stack pointer itself).!!A single register may be pulled from the stack with condition codes set by doing an autoincrement load from the stack (example: LDX ,U++).
PULUW;6309;H=• N=• Z=• V=• C=•;Pull W from User Stack;W' ← U:U+1  !U' ← U + 2!!Pulls the value for register W (E and F) from the user stack and autoincrements the contents of the user stack register. Condition codes are not affected.
ROL;6809;H=• N=↕ Z=↕ V=↕ C=↕;Rotate Memory Left;```html   !┌──────────────┐  !└─ C ←□□□□□□□□←┘  !```!!Rotates all bits of the operand one place left through the bit. This is a 9-bit rotation.
ROLA;6809;H=• N=↕ Z=↕ V=↕ C=↕;Rotate A Left;```html   !┌──────────────┐  !└─ C ←□□□□□□□□←┘  !```!!Rotates all bits of the operand one place left through the bit. This is a 9-bit rotation.
ROLB;6809;H=• N=↕ Z=↕ V=↕ C=↕;Rotate B Left;```html   !┌──────────────┐  !└─ C ←□□□□□□□□←┘  !```!!Rotates all bits of the operand one place left through the bit. This is a 9-bit rotation.
ROLD;6309;H=• N=↕ Z=↕ V=↕ C=↕;Rotate D Left;```html   !┌──────────────────────┐  !└─ C ←□□□□□□□□□□□□□□□□←┘  !```!!Rotates all bits of the operand one place left through the bit. This is a 17-bit rotation.
ROLW;6309;H=• N=↕ Z=↕ V=↕ C=↕;Rotate W Left;```html   !┌──────────────────────┐  !└─ C ←□□□□□□□□□□□□□□□□←┘  !```!!Rotates all bits of the operand one place left through the bit. This is a 17-bit rotation.
ROR;6809;H=• N=↕ Z=↕ V=• C=↕;Rotate Memory Right;```html   !┌──────────────┐  !└→ C →□□□□□□□□─┘  !```!!Rotates all bits of the operand one place right through the C (carry) bit. This is a 9-bit rotation.
RORA;6809;H=• N=↕ Z=↕ V=• C=↕;Rotate A Right;```html   !┌──────────────┐  !└→ C →□□□□□□□□─┘  !```!!Rotates all bits of the operand one place right through the C (carry) bit. This is a 9-bit rotation.
RORB;6809;H=• N=↕ Z=↕ V=• C=↕;Rotate B Right;```html   !┌──────────────┐  !└→ C →□□□□□□□□─┘  !```!!Rotates all bits of the operand one place right through the C (carry) bit. This is a 9-bit rotation.
RORD;6309;H=• N=↕ Z=↕ V=• C=↕;Rotate D Right;```html   !┌──────────────────────┐  !└→ C →□□□□□□□□□□□□□□□□─┘  !```!!Rotates all bits of the operand one place right through the C (carry) bit. This is a 17-bit rotation.
RORW;6309;H=• N=↕ Z=↕ V=• C=↕;Rotate W Right;```html   !┌──────────────────────┐  !└→ C →□□□□□□□□□□□□□□□□─┘  !```!!Rotates all bits of the operand one place right through the C (carry) bit. This is a 17-bit rotation.
RTI;6809;Condition Codes set as a direct reseult of the instruction;Return from Interrupt;CCR' ← (SP), SP' ← SP + 1, then!!| | |  !| :--- | :--- |  !IFF COR bit E is set, then: | ACCA' ← (SP), SP' ← SP + 1  !| | ACCB' ← (SP), SP' ← SP + 1  !| | DPR' ← (SP), SP' ← SP + 1  !| | IXH' ← (SP), SP' ← SP + 1  !| | IXL' ← (SP), SP' ← SP + 1  !| | IYH' ← (SP), SP' ← SP + 1  !| | IYL' ← (SP), SP' ← SP + 1  !| | USH' ← (SP), SP' ← SP + 1  !| | USL' ← (SP), SP' ← SP + 1  !| | PCH' ← (SP), SP' ← SP + 1  !| | PCL' ← (SP), SP' ← SP + 1  !| | |  !IFF CCR bit E is clear, then: | PCH' ← (SP), SP' ← SP + 1  !| | PCL' ← (SP), SP' ← SP + 1 |!!The saved machine state is recovered from the hardware stack and control is returned to the interrupted program. If the recovered E (entire) bit is clear, it indicates that only a subset of the machine state was saved (return address and condition codes) and only that subset is recovered.
RTS;6809;H=• N=• Z=• V=• C=•;Return from Subroutine;PCH ← (SP), SP' ← SP + 1  !PCL' ← (SP), SP' ← SP + 1!!Program control is returned from the subroutine to the calling program. The return address is pulled from the stack.
SBCA;6809;H=? N=↕ Z=↕ V=↕ C=↕ — Value of half-carry flag is undefined;Subtract Memory from A with Borrow;R' ← R - M - C!!Subtracts the contents of memory location M and the borrow (in the C (carry) bit) from the contents of the designated 8-bit register, and places the result in that register. The C bit represents a borrow and is set to the inverse of the resulting binary carry.
SBCB;6809;H=? N=↕ Z=↕ V=↕ C=↕ — Value of half-carry flag is undefined;Subtract Memory from B with Borrow;R' ← R - M - C!!Subtracts the contents of memory location M and the borrow (in the C (carry) bit) from the contents of the designated 8-bit register, and places the result in that register. The C bit represents a borrow and is set to the inverse of the resulting binary carry.
SBCD;6309;H=• N=↕ Z=↕ V=↕ C=↕;Subtract Memory from D with Borrow;R' ← R - M:M+1 - C!!Subtracts the contents of memory location M:M+1 and the borrow (in the C (carry) bit) from the contents of the designated 16-bit register, and places the result in that register. The C bit represents a borrow and is set to the inverse of the resulting binary carry.
SBCR;6309;H=• N=↕ Z=↕ V=↕ C=↕;Subtract Register from Register with Borrow;R1' ← R1 - R0 - C!!Subtracts the contents of register R0 and the borrow (in the C (carry) bit) from the contents of the register R1, and places the result in the register R1. The C bit represents a borrow and is set to the inverse of the resulting binary carry.
SEX;6809;H=• N=↕ Z=↕ V=0 C=•;Sign Extend B into D;| | |  !| :--- | :--- |  !| If bit seven of ACCB is set | then ACCA' ← $FF |  !| | else ACCA' ← $00 |!!This instruction transforms a twos complement 8-bit value in accumulator B into a twos complement 16-bit value in the D accumulator.
SEXW;6309;H=• N=↕ Z=↕ V=• C=•;Sign Extend W into Q;| | |  !| :--- | :--- |  !| If bit fifteen of ACCW is set | then ACCD' ← $FFFF |  !| | else ACCD' ← $0000 |!!This instruction transforms a twos complement 16-bit value in accumulator WAI into a twos complement 32-bit value in the Q accumulator.
STA;6809;H=• N=↕ Z=↕ V=0 C=•;Store A into Memory;M' ← R!!Writes the contents of an 8-bit register into a memory location.
STB;6809;H=• N=↕ Z=↕ V=0 C=•;Store B into Memory;M' ← R!!Writes the contents of an 8-bit register into a memory location.
STE;6309;H=• N=↕ Z=↕ V=0 C=•;Store E into Memory;M' ← R!!Writes the contents of an 8-bit register into a memory location.
STF;6309;H=• N=↕ Z=↕ V=0 C=•;Store F into Memory;M' ← R!!Writes the contents of an 8-bit register into a memory location.
STD;6809;H=• N=↕ Z=↕ V=0 C=•;Store D into Memory;M':M'+1 ← R!!Writes the contents of a 16-bit register into two consecutive memory locations
STW;6309;H=• N=↕ Z=↕ V=0 C=•;Store W into Memory;M':M'+1 ← R!!Writes the contents of a 16-bit register into two consecutive memory locations
STX;6809;H=• N=↕ Z=↕ V=0 C=•;Store X into Memory;M':M'+1 ← R!!Writes the contents of a 16-bit register into two consecutive memory locations
STY;6809;H=• N=↕ Z=↕ V=0 C=•;Store Y into Memory;M':M'+1 ← R!!Writes the contents of a 16-bit register into two consecutive memory locations
STS;6809;H=• N=↕ Z=↕ V=0 C=•;Store S into Memory;M':M'+1 ← R!!Writes the contents of a 16-bit register into two consecutive memory locations
STU;6809;H=• N=↕ Z=↕ V=0 C=•;Store U into Memory;M':M'+1 ← R!!Writes the contents of a 16-bit register into two consecutive memory locations
STBT;6309;H=• N=• Z=• V=• C=•;Store Register Bit into Memory;DPM.d' ← R.s!!Write bit s of the contents of register R into bit d in direct addressed memory location DPM. Condition Codes are not affected.
STQ;6309;H=• N=↕ Z=↕ V=0 C=•;Store Q into Memory;M':M'+3 ← R!!Writes the contents of an 32-bit register into four consecutive memory locations
SUBA;6809;H=? N=↕ Z=↕ V=↕ C=↕ — Value of half-carry flag is undefined;Subtract Memory from A;R' ← R - M!!Subtracts the value in memory location M from the contents of a designated 8-bit register. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry.
SUBB;6809;H=? N=↕ Z=↕ V=↕ C=↕ — Value of half-carry flag is undefined;Subtract Memory from B;R' ← R - M!!Subtracts the value in memory location M from the contents of a designated 8-bit register. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry.
SUBD;6809;H=• N=↕ Z=↕ V=↕ C=↕;Subtract Memory from D;R' ← R - M:M+1!!Subtracts the value in memory location M:M+1 from the contents of a designated 16-bit register. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry.
SUBE;6809;H=? N=↕ Z=↕ V=↕ C=↕ — Value of half-carry flag is undefined;Subtract Memory from A;R' ← R - M!!Subtracts the value in memory location M from the contents of a designated 8-bit register. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry.
SUBF;6809;H=? N=↕ Z=↕ V=↕ C=↕ — Value of half-carry flag is undefined;Subtract Memory from B;R' ← R - M!!Subtracts the value in memory location M from the contents of a designated 8-bit register. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry.
SUBR;6309;H=• N=↕ Z=↕ V=↕ C=↕;Subtract Register from Register;R1' ← R1 - R0!!Subtracts the contents of register R0 from the contents of register R1. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry.
SWI;6809;H=• N=• Z=• V=• C=•;Software Interrupt;Set E (entire state will be saved)  !SP' ← SP - 1, (SP) ← PCL  !SP' ← SP - 1, (SP) ← PCH  !SP' ← SP - 1, (SP) ← USL  !SP' ← SP - 1, (SP) ← USH  !SP' ← SP - 1, (SP) ← IYL  !SP' ← SP - 1, (SP) ← IYH  !SP' ← SP - 1, (SP) ← IXL  !SP' ← SP - 1, (SP) ← IXH  !SP' ← SP - 1, (SP) ← DPR  !SP' ← SP - 1, (SP) ← ACCB  !SP' ← SP - 1, (SP) ← ACCA  !SP' ← SP - 1, (SP) ← CCR   !Set I, F (mask interrupts)  !PC' ← ($FFFA):($FFFB)!!All of the processor registers are pushed onto the hardware stack (with the exception of the hardware stack pointer itself), and control is transferred through the software Interrupt vector. Both the normal and fast interrupts are masked (disabled).
SWI2;6809;H=• N=• Z=• V=• C=•;Software Interrupt 2;Set E (entire state will be saved)  !SP' ← SP - 1, (SP) ← PCL  !SP' ← SP - 1, (SP) ← PCH  !SP' ← SP - 1, (SP) ← USL  !SP' ← SP - 1, (SP) ← USH  !SP' ← SP - 1, (SP) ← IYL  !SP' ← SP - 1, (SP) ← IYH  !SP' ← SP - 1, (SP) ← IXL  !SP' ← SP - 1, (SP) ← IXH  !SP' ← SP - 1, (SP) ← DPR  !SP' ← SP - 1, (SP) ← ACCB  !SP' ← SP - 1, (SP) ← ACCA  !SP' ← SP - 1, (SP) ← CCR   !Set I, F (mask interrupts)  !PC' ← ($FFF4):($FFF5)!!All of the processor registers are pushed onto the hardware stack (with the exception of the hardware stack pointer itself), and control is transferred through the software interrupt 2 vector. This interrupt is available to the end user and must not be used in packaged soft- ware. This interrupt does not mask (disable) the norma! and fast in- terrupts.
SWI3;6809;H=• N=• Z=• V=• C=•;Software Interrupt 3;Set E (entire state will be saved)  !SP' ← SP - 1, (SP) ← PCL  !SP' ← SP - 1, (SP) ← PCH  !SP' ← SP - 1, (SP) ← USL  !SP' ← SP - 1, (SP) ← USH  !SP' ← SP - 1, (SP) ← IYL  !SP' ← SP - 1, (SP) ← IYH  !SP' ← SP - 1, (SP) ← IXL  !SP' ← SP - 1, (SP) ← IXH  !SP' ← SP - 1, (SP) ← DPR  !SP' ← SP - 1, (SP) ← ACCB  !SP' ← SP - 1, (SP) ← ACCA  !SP' ← SP - 1, (SP) ← CCR   !Set I, F (mask interrupts)  !PC' ← ($FFF2):($FFF3)!!All of the processor registers are pushed onto the hardware stack (with the exception of the hardware stack pointer itself), and control is transferred through the software interrupt 3 vector. This interrupt does not mask (disable) the normal and fast interrupts.
SYNC;6809;H=• N=• Z=• V=• C=•;Synchronize to External Event;When a SYNC instruction is excuted, tlie processor enters a synchronizing state, stops processing instructions, and waits for an interrupt. When an interrupt occurs, the synchronizing state is cleared and processing continues. If the interrupt is enabled, and it lasts three cycles or more, the processor will perform the interrupt routine. If the interrupt is masked or is shorter than three cycles, the processor simply continues to the next instruction. While in the synchronizing state, the address and data buses are in the high-impedance state.!!This instruction provides software synchronization with a hardware process. Consider the following example for high-speed acquisition of data:!!```!FAST   SYNC             WAIT FOR DATA!       Interrupt!!       LDA        DISC  DATA FROM DISC AND CLEAR INTERRUPT!       STA        ,X+   PUT IN BUFFER!       DECB             COUNT IT, DONE?!       BNE        FAST  GO AGAIN IF NOT.!```!!The synchronizing state is cleared by any interrupt. Of course, enabled interrupts at this point may destroy the data transfer and, as such, should represent only emergency conditions.!!The same connection used for interrupt-driven I/O service may also be used for high-speed data transfers by setting the interrupt mask and using the SYNC instruction as the above example demonstrates.
TFM;6309;H=• N=• Z=• V=• C=•;Transfer Memory;M':M'+W ← M:M+W!!Transfer the number of bytes specified in W from the source memory locations to the destination memory locations
TFR;6809;H=• N=• Z=• V=• C=•;Transfer Register to Register;R1 → R2'!!Transfers data between two designated registers. Only like size registers may be transferred. (8-bit to 8-bit, or 16-bit to 16-bit.)
TIM;6309;H=• N=↕ Z=↕ V=0 C=•;Bit Test Value with Memory;TEMP ← M ∩ I!!Performs the logical AND of the contents of the contents of memory location M and the 8-bit intermediate value and modifies the condition codes accordingly. The content of memory location M is not affected.
TST;6809;H=• N=↕ Z=↕ V=0 C=•;Test Memory;TEMP ← M - 0!!Set the N (negative) and Z (zero) bits according to the contents of memory location M, and clear the V (overflow) bit. The TST instruction provides only minimum information when testing unsigned values, since no unsigned value is less than zero, BLO and BLS have no utility. While BHI could be used after TST, it provides exactly the same control as BNE, which is preferred. The signed branches are available.
TSTA;6809;H=• N=↕ Z=↕ V=0 C=•;Test A;TEMP ← R - 0!!Set the N (negative) and Z (zero) bits according to the contents of accumulator A and clear the V (overflow) bit. The TST instruction provides only minimum information when testing unsigned values, since no unsigned value is less than zero, BLO and BLS have no utility. While BHI could be used after TST, it provides exactly the same control as BNE, which is preferred. The signed branches are available.
TSTB;6809;H=• N=↕ Z=↕ V=0 C=•;Test B;TEMP ← R - 0!!Set the N (negative) and Z (zero) bits according to the contents of accumulator B and clear the V (overflow) bit. The TST instruction provides only minimum information when testing unsigned values, since no unsigned value is less than zero, BLO and BLS have no utility. While BHI could be used after TST, it provides exactly the same control as BNE, which is preferred. The signed branches are available.
TSTD;6309;H=• N=↕ Z=↕ V=0 C=•;Test D;TEMP ← R - 0!!Set the N (negative) and Z (zero) bits according to the contents of accumulator D and clear the V (overflow) bit. The TST instruction provides only minimum information when testing unsigned values, since no unsigned value is less than zero, BLO and BLS have no utility. While BHI could be used after TST, it provides exactly the same control as BNE, which is preferred. The signed branches are available.
TSTE;6309;H=• N=↕ Z=↕ V=0 C=•;Test E;TEMP ← R - 0!!Set the N (negative) and Z (zero) bits according to the contents of accumulator E and clear the V (overflow) bit. The TST instruction provides only minimum information when testing unsigned values, since no unsigned value is less than zero, BLO and BLS have no utility. While BHI could be used after TST, it provides exactly the same control as BNE, which is preferred. The signed branches are available.
TSTF;6309;H=• N=↕ Z=↕ V=0 C=•;Test F;TEMP ← R - 0!!Set the N (negative) and Z (zero) bits according to the contents of accumulator F and clear the V (overflow) bit. The TST instruction provides only minimum information when testing unsigned values, since no unsigned value is less than zero, BLO and BLS have no utility. While BHI could be used after TST, it provides exactly the same control as BNE, which is preferred. The signed branches are available.
TSTW;6309;H=• N=↕ Z=↕ V=0 C=•;Test W;TEMP ← R - 0!!Set the N (negative) and Z (zero) bits according to the contents of accumulator W and clear the V (overflow) bit. The TST instruction provides only minimum information when testing unsigned values, since no unsigned value is less than zero, BLO and BLS have no utility. While BHI could be used after TST, it provides exactly the same control as BNE, which is preferred. The signed branches are available.
